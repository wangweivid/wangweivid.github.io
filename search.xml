<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>密码学——公钥密码体系之RSA算法2</title>
      <link href="/posts/e99890812263.html"/>
      <url>/posts/e99890812263.html</url>
      
        <content type="html"><![CDATA[<p>密码学——公钥密码体系之RSA算法2</p><h3 id="一、RSA算法背景"><a href="#一、RSA算法背景" class="headerlink" title="一、RSA算法背景"></a>一、RSA算法背景</h3><p>上一讲介绍了公钥密码体系中的背包算法，在Merkle背包算法出现后不久，便出现了第一个比较完善的公开秘钥算法RSA，它可以用于加密也可以用于数字签名（一般常用作数字签名，速度较快）。</p><p>RSA算法以它的三个发明者Ron Rivest，Adi Shamir和Leonard Adleman的名字命名。</p><p>RSA的安全基于大数分解的难度。其公开密钥和私人秘钥是一对大素数的函数。从一个公开密钥和密文中恢复出明文的难度等价于分解两个大素数之积。</p><h3 id="二、RSA算法描述"><a href="#二、RSA算法描述" class="headerlink" title="二、RSA算法描述"></a>二、RSA算法描述</h3><ol><li>为了产生两个密钥，选取两个大素数$p$和$q$.为了获得最大程度的安全性，两数的长度一样。计算乘积。<script type="math/tex; mode=display">n=pq</script></li><li>然后随机算去加密密钥$e$，使得 $e$ 和$(p-1)(q-1)$互素。最后用欧几里得扩展算法计算解密密钥$d$,以满足<script type="math/tex; mode=display">ed = 1 mod (p-1)(q-1)</script>则<script type="math/tex; mode=display">d=e^{-1}mod(p-1)(q-1)</script>其中，$d$与$n$也互素。$e$和$n$是公开密钥，两个素数$p$和$q$不再需要，他们应该被舍弃，但绝不能泄露</li></ol><p>加密消息$m$时，首先将它分成比n小的数据分组（采用二进制数，选取小于n的2的最大次幂）。也就是说，如果$p$和$q$为100位素数，那么n将有200位，每个消息分组mi应小于200位长（如果需要加密固定的消息分组，那么可以在它的左边填充0，并确保该数比n小）。加密后的密文c，将由相同长度的分组ci组成。加密公式简化为：</p><script type="math/tex; mode=display">c_i=m_i^emod(n)</script><p>解密消息时，取每一个加密后的分组ci并计算：<br><img src="https://img-blog.csdnimg.cn/20210529205337710.png" alt><br>这个公式能恢复明文，如下<br><img src="https://img-blog.csdnimg.cn/20210529205620487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt><br>消息用d加密就像用e解密一样容易。</p><p><strong>举一个简单的例子</strong>：<br>选择$p=47$，$q=71$，那么</p><script type="math/tex; mode=display">n=pq=3347</script><p>加密密钥$e$必须与$(p-1)(q-1)=46*70=3220$没有公因子。<br>随机选取$e=79$，那么：</p><script type="math/tex; mode=display">d=79^{-1}mod3220=1019</script><p>该结果使用扩展欧几里得算法求出。公开$e$和$n$，将$d$保密，丢弃$p$和$q$。</p><p>对于加密消息：$m=688232687966668003$<br>首先将其分为小的分组。在此例中，按3位数字一组就可以进行加密。这个消息将分成6个分组m，进行加密：<br>$m_1=688$<br>$m_2=232$<br>$m_3=687$<br>$m_4=966$<br>$m_5=668$<br>$m_6=003$</p><p>第一个分组加密为：<br>$688^{79}mod3337 = 1570 = c_1$<br>对随后的分组进行同样的运算产生加密后的密文：</p><script type="math/tex; mode=display">c=15702756209122762423158</script><p>解密消息时需要用解密密钥1019进行相同的指数运算。因而</p><script type="math/tex; mode=display">1570^{1019}mod3337=688=m_1</script><p>消息的其余部分可用同样的方法恢复出来</p><h3 id="三、RSA的硬件实现"><a href="#三、RSA的硬件实现" class="headerlink" title="三、RSA的硬件实现"></a>三、RSA的硬件实现</h3><ol><li>已有的RSA芯片<br><img src="https://img-blog.csdnimg.cn/20210530171636900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt></li><li><p>RSA速度<br>RSA硬件实现时，RSA比DES慢大约1000倍。最快的具有512位模数的VLSI硬件实现的吞吐量为64Kbit每秒。也有一些实现1024位RSA的加密芯片。如今设计512bit的芯片可以达到1Mb/s，该芯片在1995年制成。在智能卡中已经大量实现了RSA，这些实现都比较慢。</p><p> 有兴趣的读者可以关注我之前的专门RSA硬件设计专栏：<br><a href="https://blog.csdn.net/vivid117/article/details/114192073?spm=1001.2014.3001.5501">基于Montgomery算法的高速、可配置RSA密码IP核硬件设计系列博文</a></p><p> 软件实现时，DES大约比RSA快100倍。这些数字会随着技术发展而发生相应的变化，但RSA的速度将永远不会达到对称算法的速度。下表给出了软件实现RSA算法的情况：<br><img src="https://img-blog.csdnimg.cn/20210530172239956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt></p></li><li>RSA硬件和软件加速<br>对于RSA硬件实现，可以采用<strong>蒙哥马利算法</strong>来加速硬件。</li></ol><p>如果很适当的选择了一个$e$值，RSA加密速度将快很多。最常用的三个$e$值为3,17和65537（2^16+1）（二进制表示只有两个1，所以只需要17次乘法来实现指数运算）。<br><strong>X.509</strong>中建议采用65537；<br><strong>PEM</strong>中建议采用3；<br><strong>PKCS#1</strong>中建议采用3和65537；<br>即便是一组用户使用同样的$e$值，采用这三个值中的任何一个都不存在安全问题<br>假如已经保存了$p$和$g$值，以及诸如$dmod(p-1)、q^{-1}dmod(p-1)、modp$这类数，那么运用<strong>中国剩余定理</strong>就能使私人密钥的运行速度加快。这些数很容易从私人密钥和公开密钥中计算出来。</p><h3 id="四、RSA的安全性"><a href="#四、RSA的安全性" class="headerlink" title="四、RSA的安全性"></a>四、RSA的安全性</h3><p>对于RSA的安全性完全依赖于大数分解的难度，从技术上来说，这是不正确的，只是一种推测。<br>从数学上从未证明过，需要分解n才能从$e$和$c$中计算出$m$。用一种完全不同方法来对RSA进行密码分析还只是一种想象。如果这种新方法能让密码分析者推算出$d$,也可以作为分解大数的一种新方法。</p><p>也可以通过猜测$(p-1)(q-1)$的值来攻击RSA。但这种攻击没有分解n容易。</p><p>对于持有极端怀疑态度的人来说，有些RSA的变型已经被证明和大数分解同样困难。分解$n$是最显而易见的攻击方法。敌方手中有公开秘钥$e$和模数$n$，要找到解密密钥$d$，他们就必须分解$n$，目前，<strong>129位十进制数字的模数是能分解的临界数。所以，n应该大于这个数</strong>。</p><p>对于密码分析者来说，有可能尝试每一种可能的d，直到获得正确的一个。这种穷举攻击还没有试图分解$n$更有效。</p><p>随着时间的推移，声称已经找到破译RSA的简单方法，但直到现在这些宣称还没有强有力的证据。</p><p>还有其他的担心，大多数用于计算素数$p$和$q$的算法是有概率的，假如$p$和$q$不是素数又如何？首先可以找出这件事发生尽可能小的概率。如果不是素数，这就意味着加密和解密均不能正确的工作，可以立即放弃。出现这种问题的主要原因是素性检测是基于概率来检测的。</p><h3 id="五、对RSA的选择密文攻击"><a href="#五、对RSA的选择密文攻击" class="headerlink" title="五、对RSA的选择密文攻击"></a>五、对RSA的选择密文攻击</h3><p>有些攻击专门针对RSA的实现。他们不攻击算法本身，而是<strong>攻击协议</strong>。仅使用RSA而不重视它的实现时不够的。实现的细节其实也很重要</p><p><strong>情形1——攻击协议</strong>：Eve在Alice的通信过程中进行窃听，设法成功选取一个用她的公开秘钥加密的密文$c$，Eve想读出消息。从数学角度来说，她想得到$m$，这里：</p><script type="math/tex; mode=display">m=c^d$$为了恢复$m$，首先先选取一个随机数$r$，满足$r$小于$n$。他得到的Alice的公开秘钥$e$,然后计算：$$x=r^emodn$$$$y=xcmodn$$$$t=r^{-1} modn</script><p>如果$x=r^emodn$，那么$r=x^dmodn$<br>现在，Eve让Alice用她的私人秘钥对y签名，以便解密$y$（Alice必须对消息，而非消息的散列值签名）。记住，Alice以前从未见过$y$.Alice发送给Eve:</p><script type="math/tex; mode=display">u=y^dmodn</script><p>现在Eve计算：</p><script type="math/tex; mode=display">tumodn=r^{-1}y^dmodn=r^{-1}x^dc^dmodn=c^dmodn=m</script><p>那么Eve，现在就获得了m。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件安全技术——芯片安全设计技术1</title>
      <link href="/posts/e945235245.html"/>
      <url>/posts/e945235245.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、常见的对称算法"><a href="#一、常见的对称算法" class="headerlink" title="一、常见的对称算法"></a>一、常见的对称算法</h3><ol><li><strong>对称密码算法</strong><br>加密和解密的秘钥是一样的<br>加密过程：X是明文，K是秘钥，Y是密文<br>解密过程：Y是密文，K是秘钥，X是明文<br><img src="https://img-blog.csdnimg.cn/20210527223926475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_5,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>常见的对称算法</strong></li></ol><ul><li>AES (Advanced Encryption Standard)</li><li>DES/3DES (Data Encryption Standard)</li><li>SM4</li><li>ZUC</li><li><p>Chacha20</p><p>  按照字节来划分，前三种AES,DES, SM4可分为一类，均按照8、16字节来分组，又称为<strong>分组密码</strong>。</p><p>  对于ZUC，Chacha20则没有分组，又称为<strong>流密码</strong>。</p></li></ul><ol><li><strong>AES分组密码算法</strong><br>AES是目前国际使用最为广泛的对称密码算法<br>其算法流程为：<br><img src="https://img-blog.csdnimg.cn/20210527225009279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>AES算法有三个子类，分别为<strong>AES128、AES-192、AES-256</strong>。<br>区别：<br><strong>秘钥长度</strong>：128,192,256<br><strong>轮数</strong>：10,12,14<br>加解密的<strong>黑盒子SBOX</strong>不同<br>加解密使用<strong>轮秘钥的顺序</strong>不同</li></ol><h3 id="二、常见的使用模式与场景"><a href="#二、常见的使用模式与场景" class="headerlink" title="二、常见的使用模式与场景"></a>二、常见的使用模式与场景</h3><ol><li><p><strong>分组密码操作模式</strong><br><strong>ECB模式（电子密码本模式）</strong><br>在实际中，，加密数据往往大于8字节，16字节，最简单的方式就是将数据分割为若干个分组后，对这些分组数据分别进行加密，也就是ECB模式。</p><p> 关于操作模式说明：对于很长的数据，如1M，那么使用SM4,AES等对称密码算法，输入只能为固定字节数，如8字节或16字节。那么最简单的解决方式即为ECB模式。<br><img src="https://img-blog.csdnimg.cn/20210527225511414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>ECB模式的缺点：采用ECB模式及每个数据都分别进行加密，各个加密之间互不干扰，因此，可以从密文中可以看出对应的结构变化趋势，这对于抵抗攻击来说是不安全的。<br>类似于一个模糊的图片，虽然被加密了，但还是能够看出其中的一些信息：<br><img src="https://img-blog.csdnimg.cn/20210527225915116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><strong>CBC模式</strong><br>为了解决ECB模式的缺点，此外还有其他的模式，如CBC模式：<br><img src="https://img-blog.csdnimg.cn/20210527230135501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于CBC加密过程，每一个分组异或后会与上一个得到的结果，在进行下一次的黑盒运算。这样可以打乱每一个分组的结构信息。</p></li><li><p><strong>常见的对称算法加密模式</strong></p></li></ol><ul><li><strong>ECB</strong>-Electronic Code Book </li><li><strong>CBC</strong>-Cipher Block Chaining</li><li><strong>CTR</strong>-CounTeR</li><li><strong>GCM</strong>-Galois/Counter，用于网络通信</li><li><strong>XTS</strong>-XEX-based Tweaked-codebook mode with ciphertext Stealing，用于数据存储</li></ul><ol><li><p><strong>数据存储</strong><br>安卓7.0以及更高的版本支持<strong>文件级别的加密（FBE）</strong>。采用文件级加密时，可以使用不同的秘钥对不同的文件进行加密，也可以对加密的文件单独解密。<br><img src="https://img-blog.csdnimg.cn/20210528102704939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 所有加密都基于<strong>采用XTS模式的AES-256算法</strong>。内核的加密性能必须要在使用AES XTS时至少达到<strong>50MB/s</strong>，以确保良好的用户体验。</p><p> 因为在使用数据存储加密时，会带来性能上的瓶颈，造成性能变差，因此需要对加密的算法提出合理的要求来达到良好的用户体验。</p></li><li><p><strong>数据存储的常用模式-XTS</strong><br><img src="https://img-blog.csdnimg.cn/20210528103403976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>特点：</p></li></ol><ul><li>NIST SP800-38E (标准化模式)</li><li>无需IV,初始向量（与CBC模式不同）</li><li>i为sector number（与数据处理的位置相关）</li><li>可以随机访问</li><li>可以进行并行处理</li></ul><ol><li><strong>网络通信</strong></li></ol><ul><li>SSL/TLS（Secure Socket Layer 安全套接层）是基于HTTPS下的一个协议加密层</li><li>TLS通信中数据都会使用对称密码算法进行加密，密码算法的种类在握手阶段进行确认</li><li>TLS-AES-128-GCM-SHA256为TLS v1.3的必选算法<br><img src="https://img-blog.csdnimg.cn/20210528104103190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><ol><li><strong>网络通信加密中常见的模式——GCM模式</strong><br><img src="https://img-blog.csdnimg.cn/20210528105141149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>特点</li></ol><ul><li>NIST SP800-38D(标准)</li><li>即可以对数据加密，也可以用于提供校验值（auth tag）</li><li>处理速度可以比CBC快，因为加解密部分可以并行处理。</li></ul><h3 id="三、常见的抗攻击设计"><a href="#三、常见的抗攻击设计" class="headerlink" title="三、常见的抗攻击设计"></a>三、常见的抗攻击设计</h3><ol><li><strong>侧信道攻击防护</strong></li></ol><p><strong>思想1</strong>：对中间值进行随机化或掩码。<br><img src="https://img-blog.csdnimg.cn/2021052810540569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对<strong>中间值</strong>进行<strong>随机化处理</strong>，往往通过对中间值异或或掩码来达到随机化中间过程的目的：</p><ul><li><strong>线性操作</strong>往往使用<strong>布尔掩码</strong></li><li><strong>非线性操作</strong>使用<strong>乘法掩码、随机掩码和国定值掩码</strong></li></ul><p><strong>思想2</strong>：增加随机延迟或伪操作<br>    在功耗上无法区别延迟或者伪操作，使得攻击者无法<strong>对齐功耗曲线</strong>。<br>    <img src="https://img-blog.csdnimg.cn/20210528113405447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li><strong>FI防护（错误注入分析防护）</strong></li></ol><ul><li><p><strong>多次操作校验是否计算结果相同</strong></p><ul><li>可以使用加密后解密来判断明文是否一致，对运算<strong>前后几轮</strong>需要重点关注</li></ul></li><li><p><strong>关键参数保存CRC</strong></p><ul><li>例如秘钥的CRC值可以由硬件保存，不定时计算目前使用的秘钥CRC值是否一致<h3 id="四、对称密码算法实现"><a href="#四、对称密码算法实现" class="headerlink" title="四、对称密码算法实现"></a>四、对称密码算法实现</h3></li></ul></li></ul><ol><li><p><strong>SBOX黑盒设计实现策略</strong><br>硬件上游两种主要实现方案：<br> a. <strong>使用查找表</strong><br> b. <strong>二项式求逆</strong><br><img src="https://img-blog.csdnimg.cn/20210528114256494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> SMIC55, 100MHz，上面的是查找表实现，下面的是二项式求逆实现。可以看到查找表实现的面积大约为其一倍。一般是频率越高，二项式求逆的面积越小，因此，需要权衡面积和性能的关系（trade-off）。</p></li><li><p><strong>轮秘钥的计算逻辑</strong><br>使用两个寄存器来存储轮秘钥，regA存储第一轮或最后一轮轮秘钥，regB用于存储当前的轮秘钥(非高速应用中)</p><p> 需要有标识标志regA存储的为第一轮还是最后一轮轮秘钥</p><p> 在一个时钟周期只进行一轮（或较少轮数）运算时，避免在一开始就讲坤秘钥全部扩展完成，占用大量寄存器。</p></li><li><p><strong>密钥管理</strong><br><strong>关键密钥</strong>：关键密钥由硬件管理，软件不可见或控制访问权限，例如<strong>根密钥</strong>。</p><p> <strong>应用密钥</strong>：应用密钥由软件协调管理，增加灵活性，例如<strong>会话秘钥</strong>。</p></li></ol><p>4.<strong>指令集加速</strong><br>通过查看CPU信息来确认是否支持指令集加速</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">user@root:grep aes -o -ml &#x2F;proc&#x2F;cpuinfoaes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>openssl 1.0.1版本后，运行时期自动检测是否支持AES-NI<br>只有使用openssl EVP的接口，定义函数才能使用AES-NI</p><p>如果CPU支持AES-NI指令扩展，其性能如下：<br><img src="https://img-blog.csdnimg.cn/20210528145911921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="五、总结："><a href="#五、总结：" class="headerlink" title="五、总结："></a>五、总结：</h3><ol><li>根据应用场景选择适合的算法和模式，根据标准规范使用</li><li>大多数算法还是可以使用空间换时间的方式进行加速</li><li>物理安全设计包含前端、后端整个IC设计流程，安全性措施在设计完成后还需要经过过实验室测试</li><li>常用的硬件对密码算法往往有加速支持</li></ol>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件安全技术——芯片安全设计技术2</title>
      <link href="/posts/465465754.html"/>
      <url>/posts/465465754.html</url>
      
        <content type="html"><![CDATA[<p>硬件安全技术——芯片安全设计技术2</p><h3 id="一、常见的公钥密码算法"><a href="#一、常见的公钥密码算法" class="headerlink" title="一、常见的公钥密码算法"></a>一、常见的公钥密码算法</h3><h5 id="1-公钥密码概述"><a href="#1-公钥密码概述" class="headerlink" title="1. 公钥密码概述"></a>1. 公钥密码概述</h5><ol><li>公钥密码学与1976年由Whitfield Diffe 、Martin Hellman和Ralph Merkle公开介绍</li><li>公钥密码计数是<strong>20世界最伟大的思想之一</strong><br>由于其改变了秘钥分发的方式<br>可以广泛应用于数字签名和身份认证服务</li><li>1977年提出的<strong>RSA</strong>成为以后使用最广泛的一种非对称密码算法</li></ol><h5 id="2-RSA密码算法"><a href="#2-RSA密码算法" class="headerlink" title="2.RSA密码算法"></a>2.RSA密码算法</h5><ol><li>1977年由Ronald Rivest、Adi Shamir和Leonard Adleman发明，1978年公布。算法名称取自作者的名字<strong>首字母</strong>。</li><li>1993年发布了<strong>PKCS#1标准</strong>来说明RSA的使用规范。2000年RSA专利到期（当时ECC专利还未到期）</li><li>如今，只有短的RSA秘钥才能被强力方式破解。到2019年为止，还没有任何可靠的攻击RSA算法的方式。<strong>RSA-2048至今是安全的</strong>。</li></ol><h5 id="3-RSA算法描述"><a href="#3-RSA算法描述" class="headerlink" title="3. RSA算法描述"></a>3. RSA算法描述</h5><p><img src="https://img-blog.csdnimg.cn/20210528160127885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解密的过程主要依赖欧拉函数来正确还原明文。</p><h5 id="4-ECC椭圆曲线算法"><a href="#4-ECC椭圆曲线算法" class="headerlink" title="4. ECC椭圆曲线算法"></a>4. ECC椭圆曲线算法</h5><ol><li>1985年由Neal Koblitz和Victor Miller分别独立提出</li><li>域K上的椭圆曲线E有下述方程定义：<br><img src="https://img-blog.csdnimg.cn/20210528161054867.png" alt="在这里插入图片描述"></li><li>有两种运算法则：<strong>倍点和点加</strong><br><img src="https://img-blog.csdnimg.cn/20210528163824473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><ul><li><strong>点乘</strong>运算可以转换为<strong>点加和倍点</strong>运算</li><li>主要运算为点乘，P和Q为椭圆曲线上的点，K为标量，Q=kP，<strong>知道P与Q，很难得到k</strong></li><li><p>点乘运算类似模幂运算<br>9（0b1001）P = 2<em>2</em>2P + P</p><ol><li>不同公钥算法安全级别对比<br><img src="https://img-blog.csdnimg.cn/20210528164609190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol></li></ul><h3 id="二、常见的使用场景"><a href="#二、常见的使用场景" class="headerlink" title="二、常见的使用场景"></a>二、常见的使用场景</h3><h5 id="1-非对称算法应用"><a href="#1-非对称算法应用" class="headerlink" title="1. 非对称算法应用"></a>1. 非对称算法应用</h5><ul><li><strong>签名、验签</strong>（常用）：<br>私钥用云签名，公钥用于验签，确认签名者的身份</li><li><strong>秘钥协商</strong><br>双方协商出一个共同的秘钥</li><li><strong>加密、解密</strong><br>公钥用于加密，私钥用于解密，该方式加解密代价较大</li></ul><h5 id="2-常见应用1——网络认证"><a href="#2-常见应用1——网络认证" class="headerlink" title="2. 常见应用1——网络认证"></a>2. 常见应用1——网络认证</h5><ol><li>客户端需要<strong>验证</strong>服务端的身份或者服务端验证客户端的身份，在<strong>双方验证完身份</strong>后，通过协商的密钥</li><li>在握手阶段需要进行<strong>验签、密钥交换</strong>操作<br><img src="https://img-blog.csdnimg.cn/20210528165209479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h5 id="3-常见应用2——安全启动"><a href="#3-常见应用2——安全启动" class="headerlink" title="3. 常见应用2——安全启动"></a>3. 常见应用2——安全启动</h5></li><li>目前越来越多的设备使用了安全启动来保护安全，防止固件等呗第三方篡改</li><li>验证固件、应用的签名，但验证失败，就无法进入下一个阶段<br><img src="https://img-blog.csdnimg.cn/20210528181116715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h5 id="4-常见应用3——V2X新应用领域"><a href="#4-常见应用3——V2X新应用领域" class="headerlink" title="4. 常见应用3——V2X新应用领域"></a>4. 常见应用3——V2X新应用领域</h5></li><li><strong>频繁</strong>对周围设备发来的位置信息<strong>进行验签</strong></li><li><strong>验签速度远远大于签名速度</strong>，验签速度大于在<strong>2000次每秒</strong></li><li>目前的规范大多使用了<strong>ECDSA</strong></li></ol><h5 id="5-常见应用4——嵌入式设备"><a href="#5-常见应用4——嵌入式设备" class="headerlink" title="5. 常见应用4——嵌入式设备"></a>5. 常见应用4——嵌入式设备</h5><ol><li><p>嵌入式设备通常都有mbedtls<br><img src="https://img-blog.csdnimg.cn/20210528181702205.png" alt="在这里插入图片描述"></p></li><li><p>mbedTLS软件包提供了如下的能力<br><img src="https://img-blog.csdnimg.cn/20210528181714899.png" alt="在这里插入图片描述"></p><h5 id="6-RSA、ECC的选择"><a href="#6-RSA、ECC的选择" class="headerlink" title="6. RSA、ECC的选择"></a>6. RSA、ECC的选择</h5></li><li><strong>RSA的验签素服可以做到很快</strong>（原因是私钥可以很短）<br>例如在安全启动的场景下，如果对启动速度很敏感则很有优势</li><li><strong>ECC的验签速度一般比签名速度慢</strong><br>如果使用ECDSA并且未经优化，签名速度一般是验签的速度的两倍</li><li><strong>RSA的存储占用远远大于ECC</strong><br>对SRAM敏感的场景下，建议使用ECC算法</li><li><strong>RSA的密钥生成速度远远小于ECC</strong></li></ol><h3 id="三、常见的抗攻击设计"><a href="#三、常见的抗攻击设计" class="headerlink" title="三、常见的抗攻击设计"></a>三、常见的抗攻击设计</h3><h5 id="1-点乘，模幂的防侧信道保护"><a href="#1-点乘，模幂的防侧信道保护" class="headerlink" title="1. 点乘，模幂的防侧信道保护"></a>1. 点乘，模幂的防侧信道保护</h5><ol><li><strong>点乘</strong></li></ol><ul><li>固定时间：蒙哥马利阶乘</li><li>标量掩码：标量加上阶的随机倍数</li><li>随机坐标：对投影坐标进行随机化处理</li></ul><ol><li>模幂</li></ol><ul><li>固定时间：蒙哥马利阶乘</li><li>指数掩码：对幂指数进行拆分（欧拉函数）</li><li>底数掩码：对底数乘上随机数，在得到最终结果前脱掩码</li></ul><h5 id="2-验签的防FI（错误注入）保护"><a href="#2-验签的防FI（错误注入）保护" class="headerlink" title="2. 验签的防FI（错误注入）保护"></a>2. 验签的防FI（错误注入）保护</h5><ol><li>硬件多次校验</li><li>多次校验之间使用随机延迟</li><li>如果使用了蒙哥马利阶乘，可以利用两数之间的关系进行校验</li><li>参数进行CRC校验<h3 id="四、非对称密码算法实现"><a href="#四、非对称密码算法实现" class="headerlink" title="四、非对称密码算法实现"></a>四、非对称密码算法实现</h3><h5 id="1-层次化设计"><a href="#1-层次化设计" class="headerlink" title="1. 层次化设计"></a>1. 层次化设计</h5></li><li>根据运算调用关系进行分层<br>底层的适合用硬件来处理，顶层的适合使用软件来处理<br><img src="https://img-blog.csdnimg.cn/2021052821004735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><ul><li>底层的运算被调用频率高，使用硬件有利于增加运算效率</li><li>顶层协议级运算考虑使用软件设计以增加灵活性，但需要考虑硬件的中断设计，在硬件运算时可以释放CPU资源</li></ul><h5 id="2-选取适合的坐标系"><a href="#2-选取适合的坐标系" class="headerlink" title="2.选取适合的坐标系"></a>2.选取适合的坐标系</h5><ol><li><p>标准摄影坐标系<br><img src="https://img-blog.csdnimg.cn/20210528210421217.png" alt="在这里插入图片描述"></p></li><li><p>雅可比（Jacobian）坐标系<br><img src="https://img-blog.csdnimg.cn/20210528210432188.png" alt="在这里插入图片描述"></p><h5 id="3-预计算加速（软件实现比较多）"><a href="#3-预计算加速（软件实现比较多）" class="headerlink" title="3.预计算加速（软件实现比较多）"></a>3.预计算加速（软件实现比较多）</h5></li><li><p>对基点进行预计算<br><img src="https://img-blog.csdnimg.cn/20210528210645598.png" alt="在这里插入图片描述"></p></li><li><p>OpenSSL的预计算优化<br><img src="https://img-blog.csdnimg.cn/20210528210656895.png" alt="在这里插入图片描述"></p><h6 id="4-利用SIMD指令进行加速"><a href="#4-利用SIMD指令进行加速" class="headerlink" title="4.利用SIMD指令进行加速"></a>4.利用SIMD指令进行加速</h6></li><li>各家都有自己的SIMD指令<br>Intel:AXV2/SSE<br>ARM:NEON</li><li>利用SIMD特性，能够使运算提升数倍<br><img src="https://img-blog.csdnimg.cn/20210528211159104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3></li><li>公钥算法用于<strong>身份识别</strong>，主要应用为<strong>签名和验签</strong></li><li><strong>ECDSA/ECDH和RSA</strong>是主流的公钥密码体系中的算法，<strong>SM2</strong>是国内主要的公钥密码算法</li><li>公钥密码算法往往<strong>有吞吐数据量小</strong>，<strong>运算时间长</strong>的特性</li><li>由于公钥算法比较复杂，可以优先考虑已有的实现，避免反复造轮子。但要有优势，<strong>软硬件结合</strong>是最好的方式。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件安全技术——芯片安全设计技术3</title>
      <link href="/posts/675868658655754.html"/>
      <url>/posts/675868658655754.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、硬件安全解决方案"><a href="#一、硬件安全解决方案" class="headerlink" title="一、硬件安全解决方案"></a>一、硬件安全解决方案</h3><h5 id="1-为什么需要硬件安全"><a href="#1-为什么需要硬件安全" class="headerlink" title="1. 为什么需要硬件安全"></a>1. 为什么需要硬件安全</h5><ol><li>安全是系统级的，如果只是软件进行安全防护，那么<strong>无法建立强有力的信任根</strong></li><li>Crypto Engine只是解决了<strong>密码计算问题</strong>，只是单纯的拼凑组合是无法组成安全系统的</li><li>各种<strong>高等级的认证</strong>要求底<strong>层的核心安全，密码实现</strong>需要由硬件来完成参与</li></ol><h5 id="2-传统安全解决方案对比"><a href="#2-传统安全解决方案对比" class="headerlink" title="2. 传统安全解决方案对比"></a>2. 传统安全解决方案对比</h5><p>三种方法：MCU，TEE，SE<br>方案无好坏之分，只有是否符合系统的应用场景来选择解决方案<br><img src="https://img-blog.csdnimg.cn/20210529112656464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="3-SoC安全解决方案"><a href="#3-SoC安全解决方案" class="headerlink" title="3. SoC安全解决方案"></a>3. SoC安全解决方案</h5><ol><li>将<strong>传统的SE的功能集成到SoC中</strong>，避免了<strong>板级走线</strong>带来的安全风险</li><li><strong>避免了外部的数据传输性能的瓶颈</strong>，可以作为加速器使用</li><li><strong>无需额外的芯片，降低了整体成本</strong></li><li>目前手机AP厂商大多数使用该解决方案<h3 id="二、Root-of-Trust（信任根）"><a href="#二、Root-of-Trust（信任根）" class="headerlink" title="二、Root of Trust（信任根）"></a>二、Root of Trust（信任根）</h3><h5 id="1-信任根（RoT）是建立信任链的来源，也是SoC中安全根基"><a href="#1-信任根（RoT）是建立信任链的来源，也是SoC中安全根基" class="headerlink" title="1. 信任根（RoT）是建立信任链的来源，也是SoC中安全根基"></a>1. 信任根（RoT）是建立信任链的来源，也是SoC中安全根基</h5>其涉及<strong>安全启动</strong>、<strong>密钥管理</strong>两部分<h5 id="2-安全启动"><a href="#2-安全启动" class="headerlink" title="2. 安全启动"></a>2. 安全启动</h5></li><li>硬件负责<strong>初始化</strong>安全启动过程中需要使用的<strong>模块</strong>，例如<strong>随机数发生器、安全传感器、NVM控制器</strong>等</li><li><p>CPU从自身ROM中读取一级启动代码，对外部的二级Bootloader <strong>进行解密和验签</strong>，确保二级Bootloader的完整性和认证性<br><img src="https://img-blog.csdnimg.cn/2021052911392989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="3-密钥管理"><a href="#3-密钥管理" class="headerlink" title="3. 密钥管理"></a>3. 密钥管理</h5></li><li><p>保护密钥的<strong>机密性</strong>，密钥一般存储在NVM中</p></li><li>确认密钥的<strong>完整性</strong></li><li>提前考虑各种角色，确保在实际场景中的<strong>可用性</strong></li><li>结合芯片<strong>生命周期</strong>管控烧写、使用、debug相关权限<h3 id="三、关键安全模块"><a href="#三、关键安全模块" class="headerlink" title="三、关键安全模块"></a>三、关键安全模块</h3><h5 id="1-MPU-MMU"><a href="#1-MPU-MMU" class="headerlink" title="1. MPU/MMU"></a>1. MPU/MMU</h5>访问地址、权限隔离<h5 id="2-Crypto-Engine"><a href="#2-Crypto-Engine" class="headerlink" title="2. Crypto Engine"></a>2. Crypto Engine</h5></li><li>提供各种秘钥运算的支持</li><li>提升秘钥运算的性能和安全性</li><li><strong>避免软件可以访问关键秘钥</strong>，<strong>高等级的安全认证密钥硬件化</strong><h5 id="3-Detector"><a href="#3-Detector" class="headerlink" title="3. Detector"></a>3. Detector</h5>探测环境的异常变化<br>当在攻击硬件时，可能需要通过升压，提高频率等措施，而当SoC系统中存在这些监控异常变化时，能够及早的预防这些异常变化，从而保护硬件安全。</li></ol><h5 id="4-Storage-Protection-Unit"><a href="#4-Storage-Protection-Unit" class="headerlink" title="4. Storage Protection Unit"></a>4. Storage Protection Unit</h5><p>保护<strong>存储单元</strong>内的数据，<strong>地址总线和数据总线</strong>都需要<strong>加密、加扰</strong></p><h5 id="5-Bus-Protection-Unit"><a href="#5-Bus-Protection-Unit" class="headerlink" title="5. Bus Protection Unit"></a>5. Bus Protection Unit</h5><p>保护总线上传输的信息，地址和数据都需要<strong>加扰</strong>(实时性比较高，一般只做加扰)</p><h5 id="6-Secure-Processor"><a href="#6-Secure-Processor" class="headerlink" title="6. Secure Processor"></a>6. Secure Processor</h5><ol><li>利用<strong>Memory Tagging等技术</strong>防止关于Memory的攻击</li><li>利用<strong>Time constant计数</strong>防止Timing Attack</li></ol><h3 id="四、安全系统的应用——-智能电表"><a href="#四、安全系统的应用——-智能电表" class="headerlink" title="四、安全系统的应用—— 智能电表"></a>四、安全系统的应用—— 智能电表</h3><ol><li>智能电表是<strong>IoT典型安全敏感应用</strong><ol><li>智能电表处于一个<strong>开放的不可控的环境</strong>下</li><li>只能电表覆盖量极大，并且与基础民生相关，有着很高的价值</li><li>智能电表是一个典型的基于<strong>MCU的SoC芯片</strong>，SoC中有着很多的<strong>防护措施保护RoT和运行安全</strong><br><img src="https://img-blog.csdnimg.cn/20210529145628722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol></li></ol><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><ol><li>安全系统方案多种多样，根据实际业务场景进行选择</li><li>单一模块无法保证系统安全，系统安全需要从<strong>硬件、软件、生产和使用</strong>统筹考虑</li><li><strong>RoT需要由硬件来实现从而达到不可篡改的特性</strong></li><li>随着新兴行业（IoT,5G）的发展，硬件安全的重视程度逐渐提升</li></ol>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件安全技术——芯片安全设计技术4（PUF）</title>
      <link href="/posts/675857645754.html"/>
      <url>/posts/675857645754.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是PUF"><a href="#一、什么是PUF" class="headerlink" title="一、什么是PUF"></a>一、什么是PUF</h3><h5 id="1-物理不可克隆函数——PUF"><a href="#1-物理不可克隆函数——PUF" class="headerlink" title="1. 物理不可克隆函数——PUF"></a>1. 物理不可克隆函数——PUF</h5><p>物理不可克隆函数(即PUF：physical unclonable function)是一种芯片的<strong>数字指纹</strong>，用作半导体设备(如微处理器)的唯一身份，增强了芯片抵抗逆向的能力。</p><p>PUF通常用于密码学。物理不可克隆函数是物理结构中体现的物理实体。目前，PUF通常用集成电路来实现，通常用于对安全性要求较高的应用中。</p><p>从2010年到2013年，PUF在<strong>智能卡市场</strong>获得了关注，作为提供“<strong>硅指纹</strong>”的有前途的方式，创建了独特于个人智能卡的加密密钥。<br><img src="https://img-blog.csdnimg.cn/20210529150929642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>现在，PUF成为商用FPGA中安全替代电池备份秘密密钥的存储器，如Xilinx Zynq Ultrascale ++ 和Altera。</p><p>PUF取决于其物理微结构的独特性。<strong>这种微观结构取决于制造过程中引入的随机物理因素</strong>。这些因素是<strong>不可预测和不可控制</strong>的，这使得<strong>复制或克隆结构</strong>几乎是不可能的。</p><p>但是这只是一项芯片设计模块功能，与<strong>TrustZone技术</strong>存在本质区别。</p><h5 id="2-PUF特性"><a href="#2-PUF特性" class="headerlink" title="2. PUF特性"></a>2. PUF特性</h5><p><img src="https://img-blog.csdnimg.cn/20210529151253585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>唯一性<br>每一个芯片都是随机分布的、唯一的<ol><li>防克隆性<br>芯片本身就是在芯片制造过程中由于不确定因素提取出来的，无法重新复制相同的PUF值</li><li>不可预测性<br>由于芯片在制造出来之前，没有办法来预测</li><li>防篡改性<br>芯片本身PUF值无法定位修改</li><li>无需存储<br>每次芯片启动只需要在电路结构中提取，无需存储器件来存储</li></ol></li></ol><h5 id="3-PUF结构"><a href="#3-PUF结构" class="headerlink" title="3. PUF结构"></a>3. PUF结构</h5><p><img src="https://img-blog.csdnimg.cn/20210529152437793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li><p>SRAM PUF<br>SRAM PUF利用SRAM Cell，首尾相接的反相器，在制造过程中，虽然电路架构完全一样，但是电路驱动能力有强弱之分，导致SRAM在上电时的Cell上0,1的分布是随机分布的，因此，利用这个特征可以提取出PUF</p></li><li><p>仲裁PUF<br>仲裁PUF，同一个信号从起点到终点所用的时间（延迟），在制造过程中会存在误差。</p></li><li><p>RO PUF（环形振荡器）<br>环形振荡器PUF，利用环形振荡器电路，在不同芯片制造出来之后，频率产生也会存在误差</p></li><li><p>VIA PUF<br>实际设计中，VIA存在设计规则，利用设计规则，设计从小到大的孔洞，根据工艺的特性，来提取出VIA PUF</p></li></ol><h5 id="5-与TrustZone技术的区别"><a href="#5-与TrustZone技术的区别" class="headerlink" title="5. 与TrustZone技术的区别"></a>5. 与TrustZone技术的区别</h5><p><img src="https://img-blog.csdnimg.cn/20210529153405434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>TrustZone技术是一种安全执行区域概念，是<strong>芯片运行状态在共享资源、总线系统的安全态与非安全态</strong>的问题。基于TrustZone技术的<strong>TEEOS</strong>，形成一个可信执行环境，能够执行某些操作、保护某些资源。</p><p>PUF可以被用作<strong>唯一且不可篡改的设备标识符</strong>。PUF也可以用于安全密钥生成和存储以及随机源。</p><h3 id="二、SRAM-PUF特点"><a href="#二、SRAM-PUF特点" class="headerlink" title="二、SRAM PUF特点"></a>二、SRAM PUF特点</h3><h5 id="1-SRAM-PUF"><a href="#1-SRAM-PUF" class="headerlink" title="1. SRAM PUF"></a>1. SRAM PUF</h5><p>深亚微米工艺上来说，制造过程中随机因素会影响电路特性，从而导致Cell上电时，0与1随机分布，这个随机分布，基本上是固定的分布，这样可以提取出PUF值<br><img src="https://img-blog.csdnimg.cn/20210529160021982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="2-SRAM-PUF-Key存储"><a href="#2-SRAM-PUF-Key存储" class="headerlink" title="2. SRAM PUF Key存储"></a>2. SRAM PUF Key存储</h5><p>PUF Key在芯片生命周期使用阶段：</p><ol><li><p><strong>Enrollment——QTP</strong>(One Time Process)<br><img src="https://img-blog.csdnimg.cn/2021052916031822.png" alt="在这里插入图片描述"><br>从SRAM PUF中提取R值，经过PUF-IP，再经过AC过程（用于纠错），然后配合上电过程完成启动</p></li><li><p><strong>Key重构</strong>——每次上电都需要重新执行这个过程<br>R’值和之前R值是不一样的，由于芯片SRAM Cell 80%0,1值是确定的，但是也有少部分是随机变化的。通过AC纠错，可以保证每次SRAM生成的PUF Key是固定的。<br><img src="https://img-blog.csdnimg.cn/20210529160559890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>前提条件</strong>：<br><img src="https://img-blog.csdnimg.cn/20210529160811663.png" alt="在这里插入图片描述"><br>a. AC和Key相关性是0，即从ACcode是无法推导出PUF key<br>b. 提取出的Key值需要达到一定的可靠性</p></li></ol><h5 id="3-SRAM-PUF-产品形态"><a href="#3-SRAM-PUF-产品形态" class="headerlink" title="3. SRAM PUF 产品形态"></a>3. SRAM PUF 产品形态</h5><ol><li><p>软件形态</p></li><li><p>硬件IP形态<br><img src="https://img-blog.csdnimg.cn/20210529161152979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="4-SRAM-PUF生命使用周期"><a href="#4-SRAM-PUF生命使用周期" class="headerlink" title="4. SRAM PUF生命使用周期"></a>4. SRAM PUF生命使用周期</h5><p>软件的BROADKEY可以部署至各个生命周期的芯片上，<br><img src="https://img-blog.csdnimg.cn/20210529162213900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以保障25年的生命周期</p></li><li>可靠性</li><li>制造型</li><li>安全认证<br><img src="https://img-blog.csdnimg.cn/20210529162320386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h3 id="三、SRAM-PUF应用"><a href="#三、SRAM-PUF应用" class="headerlink" title="三、SRAM PUF应用"></a>三、SRAM PUF应用</h3><h5 id="1-生成应用Key流"><a href="#1-生成应用Key流" class="headerlink" title="1. 生成应用Key流"></a>1. 生成应用Key流</h5><p>与SRAM PUF流程一致</p><ol><li>Enrollment</li><li>Key 重构<br><img src="https://img-blog.csdnimg.cn/20210529162523286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h5 id="2-Wrap-Operation"><a href="#2-Wrap-Operation" class="headerlink" title="2. Wrap Operation"></a>2. Wrap Operation</h5><p>与之前一种的区别是，这次的Key值不作为应用密钥，<br>而是作为应用密钥的加密密钥来使用</p><ol><li><p>Enrollment<br><img src="https://img-blog.csdnimg.cn/20210529162823451.png" alt="在这里插入图片描述"></p></li><li><p>Key 编程<br><img src="https://img-blog.csdnimg.cn/20210529162833386.png" alt="在这里插入图片描述"></p></li><li><p>Key重构<br><img src="https://img-blog.csdnimg.cn/20210529162841362.png" alt="在这里插入图片描述"></p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210529162758116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="3-防克隆的应用方案"><a href="#3-防克隆的应用方案" class="headerlink" title="3. 防克隆的应用方案"></a>3. 防克隆的应用方案</h5><p><strong>安全固件的导入：</strong></p><ol><li><p>BROADKEY集成在bootloader中，含有两个内容，一个是Bootloader，另外一个为存储密钥，为固件的解密密钥。除了部件以外，还有加解密库。<br><img src="https://img-blog.csdnimg.cn/20210529163535631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>把这个固件download到产品的flash中，然后需要通过<strong>BROADKEY</strong>把 <strong>AC code</strong>提取出来，存储到数据区<br><img src="https://img-blog.csdnimg.cn/20210529163606552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li>将BROADKEY生成Key将固件的<strong>解密密钥进行加密</strong>以后，存储到flash数据区<br><img src="https://img-blog.csdnimg.cn/20210529163741262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>用固件的解密密钥将初始导入的加密固件解密出来，存储至可执行区域中<br><img src="https://img-blog.csdnimg.cn/20210529163917535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>因为固件已经解密完成，因此把bootloader中的解密密钥删除，同时导入固件的加密密钥也可以删除<br><img src="https://img-blog.csdnimg.cn/2021052916401965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>最后，用PUF Key生成MAC值，存储到数据区，以上为安全固件的导入过程<br><img src="https://img-blog.csdnimg.cn/20210529164422385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>使用过程</strong>：<br>a. 在安装过程中，固件已经装好。<br>b. 芯片上电后，bootloader可以都会AC code<br>c. 同时生成PUF key，同时利用PUF key来对固件进行计算，同时与之前MAC值进行比较。如果正确则可以执行固件，比较错误，则会进入错误状态。<br><img src="https://img-blog.csdnimg.cn/20210529164930340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>固件升级</strong><br><img src="https://img-blog.csdnimg.cn/20210529165054791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>防克隆原理</strong><br><img src="https://img-blog.csdnimg.cn/20210529165200374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果将芯片中固件放入另一个固件，即使两个芯片完全一样。<br>每次上电中，BROADKEY则会提取出PUF Key，如果芯片一旦换了之后，读取AC code进行PUF Key的提取，就会发现AC code并不是芯片本身的AC code，所以会报错。则会影响下一步的过程。因此，可以防克隆的攻击。</li></ol><h3 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h3><p>SRAM PUF的特征</p><ol><li>可以容易的加载PUF  key的功能</li><li>很高的可靠性，可以保证小于 $10^{-12}$ 错误概率</li><li>很好的工艺适配性（7nm~.13um的工艺）</li><li>安全认证高</li></ol>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件安全技术——概述1(安全威胁和硬件安全技术)</title>
      <link href="/posts/e9913346.html"/>
      <url>/posts/e9913346.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、硬件安全技术是什么？"><a href="#一、硬件安全技术是什么？" class="headerlink" title="一、硬件安全技术是什么？"></a>一、硬件安全技术是什么？</h3><ol><li>传统视角：<br><strong>硬件安全</strong>=<strong>密码芯片安全</strong>，特别是智能卡、可信计算、Ukey等芯片攻击防御技术<br><img src="https://img-blog.csdnimg.cn/20210525101630337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><p>密码芯片的逻辑接口、物理接口安全；<br>核心功能：具备防攻击能力，能有效<strong>保护秘钥存储</strong>、进行<strong>安全密码运算</strong>；<br><img src="https://img-blog.csdnimg.cn/20210525101647538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>密码芯片是一个边界清楚，作为一个黑盒子，放在系统中，起到安全密码运算、防攻击等功能。</p><h3 id="二、智联时代"><a href="#二、智联时代" class="headerlink" title="二、智联时代"></a>二、智联时代</h3><ol><li><p><strong>万物互联+智能化</strong>：<br><strong>云、端协作、数字孪生、海量数据</strong>，如智能家居、智慧城市、电力网络等迈向智能时代。<br><img src="https://img-blog.csdnimg.cn/20210525102349529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><strong>网络攻击进入物理世界</strong>:<br><strong>攻击截面扩大，风险巨大</strong>，如黑客操控物理世界产品，威胁从“谋财”升级为“害命”<br><img src="https://img-blog.csdnimg.cn/20210525102438471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因此，需要相关的技术来解决安全问题。</p></li></ol><h3 id="三、真实世界安全问题层出不穷"><a href="#三、真实世界安全问题层出不穷" class="headerlink" title="三、真实世界安全问题层出不穷"></a>三、真实世界安全问题层出不穷</h3><ol><li>监控摄像头的攻击</li><li>智能音箱攻击</li><li>服务器攻击</li><li>个人电脑攻击</li><li>电力、网络攻击<br><img src="https://img-blog.csdnimg.cn/20210525102655659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><p>如何减少这类事件的发生，因此，硬件安全技术可以有效的解决这类事件发生的概率。</p><h3 id="四、硬件安全：新视角"><a href="#四、硬件安全：新视角" class="headerlink" title="四、硬件安全：新视角"></a>四、硬件安全：新视角</h3><p><img src="https://img-blog.csdnimg.cn/20210525110558968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解决安全问题，可以分为四个部分来进行问题解决：<br>应用软件，操作系统，底层软件，硬件层（如硬件电路）</p><p>系统和固件是密不可分；<br>系统信任跟由硬件+底层软件共同保护；<br>如果底层有漏洞，那么系统肯定会被破解；</p><p>因此，硬件安全研究不仅仅局限传统的独立密码芯片研究范畴，现在考虑的是在更复杂的、开放的系统中，硬件安全能够做什么？<br>传统的硬件安全保护秘钥，未来的硬件安全除了要保护秘钥，还要保护软件，再由软件再保护上层应用。</p><p>硬件安全用在什么地方，所有联网的设备，必须用到硬件安全技术</p><p>举一个简单的IoT例子：（物联网设备、智能手机、云）<br><img src="https://img-blog.csdnimg.cn/20210525111239815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>设备端：</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">固件保护身份识别数据加解密其他<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>手机端：</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">OSAPP安全生物识别安全其他<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>云端</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">网络安全租户OS安全数据安全其他<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>硬件安全扮演的角色：<br>虽然云和端所用的芯片架构不一样，如算力、软件等。但是却有相同的硬件安全要求。<br>例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">1. 硬件需要提供安全的Boot ROM。芯片启动第一步，信任根2. 安全秘钥、ID的管理3. 加解密、签名、密码运算等秘钥安全信息4. 随机数发生器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于手机端，可能还有<strong>安全执行环境</strong>，需要run应用，如指纹、人脸。<br>对于云端，考虑运行在<strong>虚拟机上的多个用户安全需求</strong>，如每个用户可能有自己秘钥存储需求；<strong>OS的安全启动</strong>、<strong>数据安全</strong>需求；<strong>TLS的卸载</strong>等</p><h3 id="五、生命周期安全设计"><a href="#五、生命周期安全设计" class="headerlink" title="五、生命周期安全设计"></a>五、生命周期安全设计</h3><p>生命周期安全设计是硬件安全需要考虑的重点内容。<br><img src="https://img-blog.csdnimg.cn/20210525112749239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>实际在芯片的最初的RTL设计，到交付至用户的，存在很多环节。很多环节有可能导致秘钥、固件或者其他敏感信息的泄露，那么<strong>硬件安全如何在开放的供应链上构建信任根和信任链</strong>？这一点是硬件安全需要解决的问题。</p><h3 id="六、硬件安全技术"><a href="#六、硬件安全技术" class="headerlink" title="六、硬件安全技术"></a>六、硬件安全技术</h3><p><img src="https://img-blog.csdnimg.cn/20210525113107621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>硬件安全上主要研究内容可分为以下四个部分：</p><ol><li>硬件安全架构</li><li>物理攻击技术</li><li>抗攻击设计</li><li>面向软件安全的硬件设计</li></ol><h3 id="七、侧信道攻击"><a href="#七、侧信道攻击" class="headerlink" title="七、侧信道攻击"></a>七、侧信道攻击</h3><ol><li><p>侧信道攻击<br><img src="https://img-blog.csdnimg.cn/20210526100014630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210526100034348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>SCA本质上利用芯片在计算时，边信道的泄露，内部的电路的状态取决于算法的设计，例如对于8bit的寄存器，若初始值为0，一旦我们往里面写入一个字节的数据，那么在写入的过程中，部分寄存器的状态会翻转，即会引起功耗的变化（电容）。实际上，这种泄露是很危险的，并且在电路中一直存在的。</p><p> 侧信道的攻击对象发展有经历了如下过程：<br><img src="https://img-blog.csdnimg.cn/20210526100748674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一直存在的误解是，人们经常认为侧信道攻击只是对工艺落后的芯片才能进行攻击，却认为对面积大、工艺先进的芯片没有威胁，实际上这个观点是错误的，只要芯片在做密码相关的计算，就可能存在侧信道信息的泄露。</p></li><li><p><strong>侧信道攻击的分类</strong><br>除了从<strong>瞬时功耗</strong>的角度发现了可以攻击密码芯片外，此外还有<strong>电磁辐射</strong>，<strong>光子泄露</strong>，<strong>计算时间</strong>等侧信道的信息。</p><p> 侧信道攻击不需要破坏芯片或者修改软件，就可以攻击，因此其<strong>攻击门槛低，威胁较大</strong>。</p><p> 因此，<strong>抵抗侧信道攻击</strong>是安全芯片的主要的技术难点之一。</p></li></ol><h3 id="八、微架构侧信道（MASCA）"><a href="#八、微架构侧信道（MASCA）" class="headerlink" title="八、微架构侧信道（MASCA）"></a>八、微架构侧信道（MASCA）</h3><p>侧信道的其中一个分支为微架构侧信道，最近几年比较热门的侧信道。<br>微架构侧信道分析：利用处理器架构的特点，获取与敏感信息（如秘钥）相关的信息泄露（如时间），来破解系统安全防护。<br><img src="https://img-blog.csdnimg.cn/20210526101452558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如2017年，熔断和幽灵：滥用CPU推演执行功能，来构造攻击场景，对大量intel CPU均有效；<br>2018年，Foreshadow：滥用CPU推演执行破解了SGX;<br>2019年，NCC 高通 QSEE攻击：利用分支预测和cache的时序泄露，获得Trustzone之中的ECDSA私钥。</p><p>传统的攻击是需要黑客去靠近设备来达到攻击的目的，不能够批量的攻击设备，但是微结构侧信道攻击可以远程进行批量攻击。</p><h3 id="九、公钥密码算法"><a href="#九、公钥密码算法" class="headerlink" title="九、公钥密码算法"></a>九、公钥密码算法</h3><p>公钥算法的演进：<br><img src="https://img-blog.csdnimg.cn/2021052610294824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="十、硬件安全的内在挑战"><a href="#十、硬件安全的内在挑战" class="headerlink" title="十、硬件安全的内在挑战"></a>十、硬件安全的内在挑战</h3><p><img src="https://img-blog.csdnimg.cn/20210526105832382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>硬件安全设计和其他信息安全设计一样，也面临着内在的挑战。<br>首先，随着时间推移，新的攻击方法、新工具也会层出不穷，攻击者会变得越来越强，但是产品并不会变得更加抗攻击。<br>其次，设备所在的系统会更加复杂，包括网络结构、芯片架构、软件应用等。</p><p>因此，在安全设计时，<strong>最小化的安全假设，同时保持足够的功能和架构的安全性</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件安全技术——概述2(5G时代IoT环境下芯片安全风险与挑战)</title>
      <link href="/posts/e9954737564.html"/>
      <url>/posts/e9954737564.html</url>
      
        <content type="html"><![CDATA[<p>上一节中主要介绍了关于硬件安全技术和安全威胁的概述，本次主要介绍<strong>5G时代背景下IoT环境下芯片安全风险与挑战</strong>。</p><h3 id="一、5G时代下的IoT"><a href="#一、5G时代下的IoT" class="headerlink" title="一、5G时代下的IoT"></a>一、5G时代下的IoT</h3><ol><li><p>5G时代下的IoT——终端数量爆发式的增长<br><img src="https://img-blog.csdnimg.cn/20210526155349968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 随着5G技术的发展，<strong>大数据量、低延时的通讯</strong>成为可能，这给物联网世界带来了迅猛的发展，<strong>智慧交通、智慧医疗、智慧电网</strong>，这些年逐步走进生活成为现实。</p><p> 爆炸式的终端互联，已经进入每一个家庭。到2019年，消费物联网终端数量已经达到了60亿规模，工业物联网终端超过50亿。</p><p> 按照终端使用情况，我们可以把终端分为三类：<br>消费性物联网终端；<br>公共性物联网终端；<br>生产性物联网终端；</p><p> 。 <strong>5G，AI，智能IoT</strong>的有机结合是物联网终端设备发展的趋势。但是这三者的结合会带来安全性的问题。</p></li><li><p><strong>5G时代下的IoT智慧应用分层</strong><br><img src="https://img-blog.csdnimg.cn/2021052616140353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>整个IoT的体系是非常庞大的。对于每一个环节都需要去考虑其中的风险性和安全性的问题。<br>IoT给我们的生活的确带来了很多便利，但是需要注意的是，如果存在坏人或不发分子时，对我们的应用层进行修改，比如，智慧安防等，则对我们的生活带来可怕的影响。</p></li><li><p><strong>IoT智慧应用建设特点——复杂，管控难</strong><br>IoT具有复杂的系统，技术和安全参差不齐，方案各异。</p><p> <strong>安全系统集成安全<br> 代码安全控制<br> 设备可信管理<br> 安全溯源机制<br> 系统可信传递<br> 数据可信共享</strong></p><p> 针对这些复杂的问题，国际和我国均<strong>制定相应的标准</strong>来约束我们供应商的的设计产品的参数。</p></li><li><p><strong>IoT云-管-端各处的安全防御要点（腾讯物联网安全技术规范）</strong><br><img src="https://img-blog.csdnimg.cn/2021052616215656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li>总结<br><strong>IoT设备数量爆炸，不可能做到每一个设备都进行测试与管控，但是我们可以通过对设备使用芯片的安全管控来达到整体安全提升的目的。并且会有专门的第三方认证机构进行安全认证，国家在这块已经有响应的参考标准与实验室来支持。<br> IoT的供应链极长，供应链安全的管理也是其中重点部分，为来区块链的应用也许会大量落地。</strong></li></ol><h3 id="二、IoT产品面临的实际威胁"><a href="#二、IoT产品面临的实际威胁" class="headerlink" title="二、IoT产品面临的实际威胁"></a>二、IoT产品面临的实际威胁</h3><p>互联网安全事件的安全威胁的一些例子：<br>物联网<br><img src="https://img-blog.csdnimg.cn/20210526222602374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>IoT终端设备安全需求：<br><img src="https://img-blog.csdnimg.cn/20210526222747253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="三、如何做好芯片的核心防护"><a href="#三、如何做好芯片的核心防护" class="headerlink" title="三、如何做好芯片的核心防护"></a>三、如何做好芯片的核心防护</h3><ol><li><p>芯片的核心资产<br><strong>芯片服务于应用，芯片安全最终是为了防护应用信息安全</strong>，如以下几个部分：<br><img src="https://img-blog.csdnimg.cn/20210526222857955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>芯片安全设计需要遵循响应的规范</p></li><li><p>以秘钥和密码算法来武装芯片系统<br>合理的<strong>秘钥和密码算法</strong>的设计赋予了芯片安全基石，结合硬件隔离技术简历整个芯片安全系统<br><img src="https://img-blog.csdnimg.cn/20210526223138220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>以方案将应用于芯片串联起来<br>以AI芯片防护为例，使用安全方案将芯片的安全属性付给AI的敏感信息<br><img src="https://img-blog.csdnimg.cn/20210526223320267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.以标准出发安全设计<br><img src="https://img-blog.csdnimg.cn/20210526223507997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从应用领域出发，引出相关标准、认证，从认证，标准出发设计定义安全芯片；</p><p> 以安全芯片为核心安全能力模块，向上满足响应的标准与认证，从而满足各个应用的安全；</p><p> 当没有行业标准的时候，请参考通用的安全标准，例如<strong>国密芯片，密码模块</strong>等标准。</p></li><li><p>以国密标准出发的安全设计<br><img src="https://img-blog.csdnimg.cn/20210526223820621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol><p><img src="https://img-blog.csdnimg.cn/2021052622384797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学-公钥密码体系之背包算法1</title>
      <link href="/posts/e9912263.html"/>
      <url>/posts/e9912263.html</url>
      
        <content type="html"><![CDATA[<p>密码学——公钥密码体系之背包算法1</p><p>众所周知，公钥密码，又称非对称密码，比较常见的是基于以下三种数学难题的公钥密码体制；</p><ol><li>大数因子分解难解性（RSA）</li><li>离散对数难解性（ElGamal）</li><li>椭圆曲线离散对数难解性（ECC）</li></ol><h3 id="1-背包算法"><a href="#1-背包算法" class="headerlink" title="1.背包算法"></a>1.背包算法</h3><p>本次介绍的并不是以上三种类型的公钥密码体制，而是在公钥密码出现之前，就已经存在的公开密码加密算法：背包算法；<br>背包算法是由Merkle和Hellman开发的背包算法。只能用于加密，后来由Shamir将它改进，使之也能用于数字签名；</p><p>背包算法的安全性起源于背包难题，他是一个<strong>NP完全</strong>问题，但后来发现该算法并不安全，但是由于它证明了如何将NP完全问题用于公开秘钥密码学，因此，值得去学习。</p><p>下面介绍一下什么是背包算法：<br>描述：给定一个物品，每个重量不同，能否将这些物品中的几件放入一个背包中，使之等于一个给定的重量？<br>公式化描述：给定一系列值M1,M2，…，Mn，和一个S值，计算bi,使之满足：</p><script type="math/tex; mode=display">S = b1 M1 + b2M2 + ... + bnMn</script><p>$bi$值可为0,1。1表示这个物品在背包中，0表示不存在；</p><p>举一个简单的例子：<br>这些物品可能分别重1、5、6、11、14、20，可以用5、6和11组装为一个重为22的背包，而组装一个重为24的背包则是不可能的。<br>一般来说，解决这个问题所需要的的时间似乎是随着物品个数的增加，呈指数增长；</p><p>Merkle-Hellman背包算法的思想是将消息编码为背包问题的解。明文分组长度等于堆中物品的个数，并且明文位与b的值相对应，密文则是计算得到的和值，下图给出了一段用例子中背包问题来加密的明文；<br><img src="https://img-blog.csdnimg.cn/20210512193204589.png" alt="在这里插入图片描述"><br>背包实际上存在两类不同的背包问题：</p><ol><li>线性时间内可解；</li><li>线性时间内不可解；<br>容易解的背包问题可以修改成难解的背包问题。公开秘钥使用难解的背包问题，可以很容易的用来加密明文，但不能用来解密密文，私人秘钥用容易解的背包问题，他给出一个解密的简单方法。不知道私人秘钥的人要破解密文，必须解一个难得背包问题。</li></ol><h3 id="2-超递增背包"><a href="#2-超递增背包" class="headerlink" title="2.超递增背包"></a>2.超递增背包</h3><p>对于易解的背包问题，可以选择<strong>超递增序列</strong>，那么相应的背包问题容易求解。<br>超递增序列：<strong>它的每一项都大于它之前所有项之和</strong>，例如{1，3,6，13，27，52}是一个超递增序列，而{1，3，4，9，15，25}则不是。</p><p>超递增背包问题的解很容易找到，计算其总量并与序列中最大的数比较，如果总重量小于这个数，则它不在背包中，如果总重量大于这个数，则它在背包中，背包重量减去这个数，进而考察序列中下一个最大的数，重复直到结束。如果总重量减为0，那么只有一个解，否则，无解。</p><p>例如，总重量为70的一个背包，超递增序列为{2，3，6，13，27，52}；最大重量为52，小于70，所以52在背包中，70-52 = 18，下一个重量27 &gt;18，因此，27不在背包中，在下一个13&lt;18，13在背包中，18-13 = 5，以此类推，再下一个，3与2均在背包中，总重量减为0，表明已求出一个解，如果这个一个M-H背包加密分组，那么对应的密文70的解为110101.</p><p><strong>非超递增序列的背包是困难的问题，它们没有快速算法</strong>。要决定哪一项在背包中的唯一方法，是依次测试所有解，直到你得到正确的解为止。最快的算法仍随背包中物品超递增问题困难，对于后者，当你加入一项到序列中，求解只需要再进行一次运算。</p><p>Merkle-Hellman背包算法就是利用这个性质。私人秘钥是一个超递增背包问题的重量序列。公开秘钥是有相同解的普通背包问题的序列，Merkle和Hellman设计了一种方法可将超递增背包问题转化为普通的背包问题，它们用模运算来完成此变化。</p><h3 id="3-私人秘钥产生公开秘钥"><a href="#3-私人秘钥产生公开秘钥" class="headerlink" title="3.私人秘钥产生公开秘钥"></a>3.私人秘钥产生公开秘钥</h3><p>下面说明如何由背包算法由私人秘钥产生公开秘钥：<br>取一个递增序列，如 =={2，3，6，13，27，52}==，用n去乘所有的项，再用m做模数进行模运算，这个模数应比序列中所有的数的和还要大，如105。乘数应与序列中的任何一个数没有公因子，比如31。因此，一般的背包序列为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">2*31 mod105  &#x3D; 623*31 mod105  &#x3D; 936*31 mod105  &#x3D; 8113*31 mod105  &#x3D; 8827*31 mod105  &#x3D; 10252*31 mod105  &#x3D; 37<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，得到的背包为{62,93,81,88,102,37}。<br>超递增背包序列就是私人秘钥，而得到的背包序列就是公开秘钥。</p><h3 id="4-加密过程"><a href="#4-加密过程" class="headerlink" title="4.加密过程"></a>4.加密过程</h3><p>要加密一个二进制的消息，首先将它分成长度等于背包序列中详述的许多分组。然后，用1表示该项存在，用0表示该项不存在，计算背包的总重量。对所有分组都重复这个运算。<br>例如，如果消息是二进制数011000110101101110，采用上面的背包算法的加密过程如下：</p><p><strong>消息 = 011000   110101  101110<br>011000对应 93 + 81 = 174<br>110101对应 62 + 93 + 88 + 37 = 280<br>101110对应 62 + 81 + 88 + 102 = 333</strong></p><p>因此，密文为 174， 280， 333</p><h3 id="5-解密过程"><a href="#5-解密过程" class="headerlink" title="5.解密过程"></a>5.解密过程</h3><p>接收者直到私人秘钥：原始的超递增背包、用于把它转换成一般背包的n和m的值，为解密消息，接收者必须首先计算出$n^{-1}$以满足$n*n^{-1} == 1 mod m$。用$n^{-1}$模m乘密文值得每项，然后用私人背包对它进行划分就可获得明文。</p><p>在本例中，超递增背包:<br>=={2，3，6，13，27，52}==<br>m = 105, n = 31，密文消息为174,280，333。$n^{-1} = 61$，所以密文值必须用61模105乘。<br>174 <em> 61 mod 105 = 9 = 3 + 6  对应0111000；<br>280 </em> 61 mod 105 = 70 = 2 + 3 + 13 + 52  对应110101；<br>333 * 61 mod 105 = 48 = 2 + 6 + 13 + 27  对应0111000；<br>因此，恢复出的明文为011000   110101  101110</p><h3 id="6-实际的实现方案"><a href="#6-实际的实现方案" class="headerlink" title="6.实际的实现方案"></a>6.实际的实现方案</h3><p>要解决仅有6项背包序列的问题不是很难，甚至对非超增序列也是一样。实际使用的背包算法至少应该包含250项。在超递增背包中，每项值一般为200~400位。模数一般为100 ~ 200位。该算法在实际使用中，用随机序列发生器来产生这些值。</p><p>对这样的背包，试图用穷举攻击来破译是无用的。即使一台计算机每秒能计算100万次，试完所有可能的背包值，也需要 $10^{46}$ 年。</p><h3 id="7-背包的安全性"><a href="#7-背包的安全性" class="headerlink" title="7.背包的安全性"></a>7.背包的安全性</h3><p>既然上面说了即使使用穷举攻击无法破译，那么为什么该算法被证明还是可以破解？<br>Shamir支出某些情况下，背包算法能被破译，具体可以查阅相关文献。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学-基础知识概述</title>
      <link href="/posts/9178982e.html"/>
      <url>/posts/9178982e.html</url>
      
        <content type="html"><![CDATA[<h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><p>密码只是信息安全的一部分，它的目的很明确就是为了解决信息安全问题。不同的密码技术算法解决不同的信息安全问题，但没有一种技术能解决所有信息安全问题。</p><p>信息安全有四类特性：</p><ul><li>机密性：为了防止信息被窃听，对应的密码技术有对称密码和非对称密码。</li><li>完整性：为了防止信息被篡改，对应的密码技术有单向散列函数、消息认证码、数字签名。<ul><li>认证：为了防止攻击者伪装成真正的发送者，对应的密码技术有消息认证码和数字签名。</li><li>不可否认性：为了防止发送者事后否认自己没有做过，对应的密码技术为数字签名。</li></ul></li></ul><p>为了尽可能的解决不同的信息安全特性，我们可能需要组合使用多种密码技术。信息安全面临的威胁点和所对应的密码技术之间的关系可用下图来表示：<br><img src="https://img-blog.csdnimg.cn/20210506160358663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt><br>以上主要从类别分类包括6种密码技术：</p><ol><li>对称密码</li><li>非对称密码</li><li>单向散列函数 </li><li>消息认证码 </li><li>数字签名</li><li>伪随机数生成器</li></ol><p>如果看具体的算法，那就包括 <strong>AES、RSA、MD5、SHA1、SHA256、HMAC</strong> 等。有些人还将 BASE64 也理解为一种加解密的密码技术，但BASE64 只是一种编码方式，和 ASCII 和 UTF-8 编码的本质上一样，主要用途就是将不可打印的二进制数据编码为可打印的字符串，因为它不解决信息安全四个特性中的任何一种。大家都知道高性能和高安全是很难兼顾，鱼和熊掌不可兼得，我们能做的是尽力根据自己的业务找到平衡点。下面分别介绍一下这些技术和他们对应的具体算法。</p><h3 id="2、对称加密"><a href="#2、对称加密" class="headerlink" title="2、对称加密"></a>2、对称加密</h3><p>对称加密也称为共享密钥密码、私钥密码，是指用相同的密钥加密和解密时的方式。对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。缺点是，交易双方都使用同样钥匙，密钥的分发和管理比较困难，安全性得不到保证。</p><p>常用的对称加密算法有：<strong>DES、3DES、AES、Blowfish、RC5、IDEA</strong> 等，其中DES已经可以现实中被暴力破解，现在的使用最广泛的对称加密算法是 AES。密码算法可以分为分组密码和流密码两种。其中AES和DES都是属于分组密码。分组密码是将明文消息分成一定长度的N个分组，然后对每个分组进行加密。AES的分组长度是128比特，分组密码有很多模式，如果模式选择不恰当，就无法充分保证机密性。</p><p> AES 是一种分组密码，即将明文消息拆分为一定长度的N个分组，然后对每个分组进行加密。AES 的分组长度固定为 128 比特，而密钥可以是 128/192/256比特。既然是固定长度的分组，那我们要加密任意长度的明文，就涉及到如何将多个分组进行迭代加密的问题，因此，就有了分组模式。常用的分组模式有：<strong>ECB、CBC、CFB、OFB、CTR 等</strong>。最常用的是ECB 和 CBC模式，因此，需要了解下这两种模式的用法和区别。</p><p>ECB 全称为 Electronic CodeBook，电子密码本模式，是最简单的一种模式，它直接将明文分割成多个分组并逐个加密，如下图：<br><img src="https://img-blog.csdnimg.cn/20210506160557357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt><br> 这种模式的优点就是简单、快速，加密和解密都支持并行计算。而缺点也比较明显，因为每个明文分组都各自独立地进行加密和解密，如果明文中存在多个相同的明文分组，则这些分组最终会被转换为相同的密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码。另外，攻击者可以通过改变密文分组的顺序，或删除密文分组，或替换掉密文分组，就可以达到对明文操纵的目的，而无需破译密码。在实际应用中，很少需要进行并行计算的加解密场景，因此，一般情况下不会采用这种分组模式，而更推荐采用 CBC 模式。</p><p>CBC 全称为 Cipher Block Chaining，密文分组链接模式，是将前一个密文分组与当前明文分组的内容混合起来进行加密的，如下图：<br><img src="https://img-blog.csdnimg.cn/20210506160630995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt><br>在 CBC 模式中，首先将明文分组与前一个密文分组进行 XOR 运算，然后再进行加密。加密第一个明文分组时，由于不存在“前一个密文分组”，因此需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组”，这个比特序列称为初始化向量(initialization vector)，通常缩写为 IV。CBC 模式避免了 ECB 模式的弱点，明文的重复排列不会反映在密文中。不过，相比 ECB 模式，CBC 模式多了一个初始化向量IV。</p><p>另外，当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行填充，填充方式也有很多种，常用的有两种：PKCS#5 和 PKCS#7。需要注意的就是，不同编程语言使用的填充方式可能会不同。比如，Java 是使用 PKCS#5，而 iOS 的 Objective-C 和 Swift 则采用 PKCS#7。不过，对于 AES 来说，两种填充方式是一样的。</p><p>下图给出了AES加解密的流程示意图<br><img src="https://img-blog.csdnimg.cn/20210506161630288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt></p><p>　　在实际应用中，我们一般都是在前端对密码或其他敏感数据进行加密，然后在后端进行解密。因为前后端涉及到不同语言的实现，为了保证前后端经过加解密后的结果一致，有几个参数是需要保持一致的：</p><ul><li><p>(1) <strong>密钥</strong>：密钥都要使用同一个，这点基本没有疑问，但需要注意的就是，密钥长度需要统一为 128/192/256 比特，即 16/24/32 字节。</p></li><li><p>(2) <strong>分组模式</strong>：分组模式推荐统一为 CBC 模式，且要显式声明，因为不同语言的默认分组模式可能会不同。</p></li><li><p>(3) <strong>初始化向量</strong>：加密和解密时的初始化向量 IV 也是要一致的，同样也不要使用默认设置，而要显式定义。</p></li><li><p>(4) <strong>填充方式</strong>：Java 采用 PKCS5Padding，iOS 和 JavaScript 采用 PKCS7，对于 AES 来说，两者是一样的。</p></li></ul><p>　　还有一点也需要注意，AES 算法本身操作的都是 byte 字节数组，因此，加密后一般会使用 BASE64 编码将 byte 数组转为字符串，而解密之前则先用 BASE64 解码将字符串转回 byte 数组。</p><p>　　使用对称加密最关键的就是要保证密钥的安全，一般不建议直接在网络上传输密钥，另外，在客户端也要做好密钥的安全存储。　　</p><h3 id="3、非对称加密"><a href="#3、非对称加密" class="headerlink" title="3、非对称加密"></a>3、非对称加密</h3><p>　　非对称加密也称公钥加密，使用了一对密钥，用公钥进行加密，再用配对的私钥进行解密。公钥是公开的，而私钥是保密的。相比对称加密安全性提高了，但牺牲了性能，加解密的速度慢了几个数量级，消息越长，加密和解密的速度越慢。</p><p>　　使用最广泛的非对称加密算法就是 RSA，其原理是利用了大整数质因数分解问题的困难度，加密和解密其实就是非常简单的两条公式：</p><p>　　<strong>加密：密文 ＝ 明文^E mod N<br>解密：明文 ＝ 密文^D mod N</strong></p><p>　　即是说，加密就是对明文的 E 次方后除以 N 求余数的过程，其中 E 和 N 的组合就是公钥，即公钥 = (E, N)。而解密过程就是对密文进行 D 次方后除以 N 得到余数，即是明文，D 和 N 的组合就是私钥，即私钥 = (D, N)。公钥和私钥共有的 N 称为 module，即模数，E 和 D 则分别是公钥指数和私钥指数。因为 RSA 是基于以上数学问题的，所以其明文、密钥和密文都是数字，我们平时看到的字符串其实都是二进制表示的数字经过 BASE64 编码的。</p><p>　　密钥长度越长越安全，推荐使用 1024 比特或更大的值，这里说的 1024 密钥长度其实是指模数的长度。还有，不同于对称密码可以加密任意长度的明文，RSA 明文长度是不能超过密钥长度的。Java 默认的 RSA 加密实现明文长度最长为密钥长度减去 11 字节，假如密钥长度设为 1024 比特，即 128 字节，那明文长度则不能超过 128 - 11 = 117 字节，如果超过该长度则会抛异常。如果想要加密的明文比较长，那就生成更长的密钥，如 2048 比特，那明文可以长达 245 字节，足够了。太长的明文也不推荐使用 RSA 进行加密，性能太低了。 </p><p>　　另外，为了提高安全性，RSA 加密时都会填充一些随机数。RSA 加密填充方式主要有三种：NoPadding、PKCS1Padding、OAEPPadding。其中，最常用的就是 PKCS1Padding，它会在明文前面填充 11 字节的随机数，因此，对同一明文每次加密产生的密文都会不一样。如果想让每次加密产生的密文都一样，那填充方式就采用 NoPadding，即不填充，但这样无疑减低了安全性，所以一般不建议采用 NoPadding。</p><p>　　实际应用中，我们不会直接对长消息进行非对称加密，而只会对一些安全性要求非常高的短消息进行加密，比如用户的密码、对称加密的密钥。SSL/TLS 的加密方案就是用对称加密对请求消息进行加密，用公钥加密对对称加密的密钥进行加密。</p><p>想要破解就得通过n算出p和q，但是b比较大，大数的质因分解困难，但是量子计算机很有可能破解。</p><h3 id="4、单向散列函数"><a href="#4、单向散列函数" class="headerlink" title="4、单向散列函数"></a>4、单向散列函数</h3><p>　　对称加密和非对称加密主要是用来解决消息的机密性问题的，即可以防止消息被窃听导致秘密泄露，但却无法校验消息是否被篡改。要校验消息是否被篡改，就要对消息进行完整性校验，有多种校验方案，最简单高效的就是单向散列函数。</p><p>　　单向散列函数也称哈希函数、杂凑函数、消息摘要算法等，是能把任意长的输入消息串转变成固定长的输出串的一种函数，输出值称为“散列值”或“消息摘要”，也称为消息的“指纹”。使用单向散列函数，同一消息会生成同样的散列值，而只要改了消息，哪怕只改了 1 个字节，最终的散列值变化也很大，因此，很适合用这个散列值校验消息的完整性。</p><p>　　最常用的单向散列函数就是 <strong>MD5</strong> 和 <strong>SHA</strong>，SHA 其实包括了 SHA-1、SHA-224、SHA-256、SHA-384 和 SHA-512，后四种并称为 SHA-2。有时候，我们去下载一些软件的安装文件时，官方一般都会提供对应该文件的 MD5 和 SHA-1 的散列值，以便我们可以对下载后的文件自己生成散列值，再和官方提供的散列值进行比对，就知道这个文件有没有被修改过。</p><p>　　在我们平时的实际应用中，倒是很少会单独使用单向散列函数，一般都会结合其他技术一起使用。毕竟，单独使用的安全性不高。就举用户密码的安全来说吧，很多应用会将用户密码直接 MD5 之后传输给服务端。这种方案主要存在两个安全隐患，一是对于一些不够复杂的密码难以防范彩虹表，二是不同用户如果设置了相同密码那散列值无疑会一样。</p><p>　　先说第一点，首先，先了解下什么是彩虹表。彩虹表是一个用于单向散列函数逆运算的预先计算好的表，为了破解密码的散列值而准备。我们可以简单理解为彩虹表就是在明文和密文之间建立起对应关系的字典表，可以通过已知的密文反查出明文，虽然实际上其原理远比想象中复杂得多。比如说，密码“123456”的 MD5 结果是“E10ADC3949BA59ABBE56E057F20F883E”，那我监听到用户登录的请求，拿到“E10ADC3949BA59ABBE56E057F20F883E”这个密码串时，从准备好的彩虹表中就可以反查出原密码是“123456”。</p><p>再说第二点，设置了相同密码的不同用户，由于他们 MD5 后的散列值全都一样，那么只要破解了其中一个密码，就等于破解了多个用户的密码。</p><p>　　为了应对以上两个问题，比较好的方案就是 MD5 + salt，也称 MD5 加盐，即将原密码拼上一串盐值 salt 之后再进行 MD5。盐值 salt 是一个随机字符串，每个用户的 salt 值一般都是不同的，这样就可以保证不同用户最终 MD5 出来的散列值不一样，而且因为有一串随机字符串，彩虹表也很难发挥作用了。</p><h3 id="5、消息认证码"><a href="#5、消息认证码" class="headerlink" title="5、消息认证码"></a>5、消息认证码</h3><p>　　消息认证码是一种确认完整性并进行认证的技术，英文名称为message authentication code，简称为MAC。 </p><p>　　虽然单向散列函数可以用来对消息进行完整性校验，但无法校验消息是否来自合法的发送者，即无法解决认证问题。要解决发送者的认证问题，最常用的有两种方案，一是采用消息认证码，二是使用数字签名。这一小节我们先来了解下消息认证码。 </p><p>　　消息认证码的输入包括任意长度的消息和一个发送者与接收者之间共享的密钥，它可以输出固定长度的数据，这个数据称为 MAC 值。 </p><p>　　消息认证码的实现方式有很多种，最常用的实现方式就是 HMAC，再具体点，根据使用哪种单向散列函数可分为：HMAC-MD5、HMAC-SHA1、HMAC-SHA256 等等。HMAC 简单理解就是带有密钥的散列函数，因为有了密钥，就可以对发送者进行认证；也因为使用了散列函数，也具有完整性校验的性质。 </p><p>认证的基本流程就是：</p><ul><li>发送者使用共享密钥对消息计算 MAC 值；</li><li>发送者将消息和 MAC 值一起发送给接收者；</li><li>接收者收到消息和 MAC 值后，使用同一个共享密钥对消息计算 MAC 值；</li><li>对比计算出来的 MAC 值和接收到的 MAC 值是否一致，一致则认证成功。</li></ul><p>　　现在，很多接口所添加的 URL 签名机制，其实就是对请求做 MAC 认证，具体的设计细节后面的文章再详细说明。不过，因为使用了共享密钥，因此也存在和对称加密一样的密钥安全问题</p><h3 id="6、数字签名"><a href="#6、数字签名" class="headerlink" title="6、数字签名"></a>6、数字签名</h3><p>　　数字签名相当于现实世界中的盖章、签字的功能，使用数字签名可以识别篡改和伪装，还可以防止否认。 </p><p>　　数字签名可以解决发送者的认证问题，而且，数字签名还具有不可抵赖性。数字签名的原理也非常简单，其实就是将非对称加密反过来用。我们知道，非对称加密是用公钥加密，然后用私钥解密。而数字签名则是用私钥加密，生成的密文就是数字签名，再用公钥解密。用私钥进行加密这一行为只能由持有私钥的人完成，正是基于这一事实，才可以将用私钥加密的密文作为签名来对待。而由于公钥是对外公开的，因此任何人都可以用公钥进行解密，即任何人都能够对签名进行验证。</p><p>　　另外，我们也知道，非对称加密本身加密和解密是非常慢的，消息越长，性能越慢，因此，一般不用来加密和解密长消息。同样的，一般也不会直接对长消息签名，通常的做法是对消息的散列值进行签名，因为散列值比较短，所以加密签名相对就会快很多。因此，你会看到数字签名有类似 MD5withRSA、SHA1withRSA 这样的实现。</p><p>　　最后，需要注意一点，像 MD5withRSA 和 SHA1withRSA 这样的数字签名实现可以校验消息完整性、对发送者进行认证、还可防止抵赖，但却不能解决机密性的问题，不要妄想用一种密码技术就能解决所有问题。</p><p>　　不过，数字签名其实不太适合直接用在客户端上。因为客户端要对消息签名，那么客户端就需要保存私钥，那依然有私钥的安全配送和存储问题。数字签名使用最广泛的应该就是用在数字证书上了，这还涉及到 SSL/TLS 和 CA 等，后面的文章再聊这个话题。</p><h3 id="7、伪随机数生成器"><a href="#7、伪随机数生成器" class="headerlink" title="7、伪随机数生成器"></a>7、伪随机数生成器</h3><p>　　伪随机数生成器并不直接解决信息安全问题，但它承担了密钥生成的重要职责。而密钥的重要性就不用多说了。</p><h3 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h3><p>密码技术其实非常多，还包括各种单一技术的组合，我们本篇文章所学的只是最基础的一些知识，包括了对称加密、非对称加密、单向散列函数、消息认证码、数字签名这些密码技术的一些必备知识点，只有掌握了这些，才能理解和设计一些安全性更高的应用。 </p><p>　　对称加密和非对称加密用来解决机密性问题，对称加密的速度快，适合用来加密长消息，但密钥在安全配送和客户端的存储是个难点；而非对称加密避免了共享密钥的安全配送和存储问题，但对长消息的加密速度非常慢，只适合用来加密短消息。单向散列函数可以用来对消息进行完整性校验，但很少单独使用。消息认证码简单理解就是带密钥的单向散列函数，既能校验完整性，还能对发送者进行认证，但因为使用了共享密钥，也存在和对称密码一样的共享密钥的安全配送和存储问题。数字签名能解决完整性校验、认证和防止抵赖等问题，最广泛的应用是在数字证书上。</p><p>参考博文：<a href="https://blog.csdn.net/lanxue0803/article/details/80137279">https://blog.csdn.net/lanxue0803/article/details/80137279</a></p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
