<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数字IC设计10——verilog编写6（脉冲同步器）</title>
      <link href="/posts/91724fff.html"/>
      <url>/posts/91724fff.html</url>
      
        <content type="html"><![CDATA[<p>数字IC设计verilog编写——6脉冲同步器</p><ol><li>脉冲同步器<br>首先在源时钟域进行信号翻转，在跨时钟域到des_clk，并进行边沿检测，即为dec_clk时钟域的脉冲，实现脉冲同步；<br><img src="https://img-blog.csdnimg.cn/20210605113510507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>脉冲同步器的使用中，快时钟的有效信号需要是单脉冲信号，并且两个有效信号的时间间隔需要大于等于两个同步器的时钟周期，否则，无法恢复出有效信号。</li></ol><p>在实际的电路设计中，<strong>异步电路的设计</strong>在实际应用中的重要意义不言而喻。由于信号在不同时钟域之间传输，容易发生<strong>亚稳态</strong>的问题导致，不同时钟域之间得到的信号不同。</p><p>处理亚稳态常用打两拍的处理方法。</p><p>多时钟域的处理方法很多，最有效的方法异步fifo,异步fifo适合处理不同时钟域之间传输的数据组，但有时不同时钟域之间<strong>仅仅传递脉冲</strong>，异步fifo就显的有点大材小用的，因此单信号的跨时钟域处理通常有：</p><ul><li>两级寄存器串联。</li><li><strong>脉冲同步器</strong>。</li><li>结绳法。</li><li>采用握手。</li></ul><p>脉冲同步器一般用在快时钟域信号进入慢时钟域的电路设计中</p><ol><li><strong>RTL 代码</strong></li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#96;timescale 1ns &#x2F; 1psmodule pluse_sync(          input src_clk,          input src_rst_n,          input s_pluse,          input des_clk,          input des_rst_n,          output des_pluse);                                    reg src_pluse;always @ (posedge src_clk or negedge src_rst_n)    if(!src_rst_n)        src_pluse &lt;&#x3D; 1&#39;b0;    else if(s_pluse)        src_pluse &lt;&#x3D; ~src_pluse;        reg d_reg1,d_reg2;always @ (posedge des_clk or negedge des_rst_n)    if(!des_rst_n)        &#123;d_reg1,d_reg2&#125; &lt;&#x3D; 2&#39;b00;    else        &#123;d_reg1,d_reg2&#125; &lt;&#x3D; &#123;src_pluse,d_reg1&#125;;assign des_pluse &#x3D; (d_reg1 !&#x3D; d_reg2) ? 1&#39;b1:1&#39;b0;endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210605112000275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Digital IC Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Verilog </tag>
            
            <tag> 脉冲同步器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字IC设计9——verilog编写5（无毛刺时钟MUX设计）</title>
      <link href="/posts/9172577577777.html"/>
      <url>/posts/9172577577777.html</url>
      
        <content type="html"><![CDATA[<p><strong>1.Glitch Free技术</strong></p><p>在时钟切换时，需要涉及到时钟切换的MUX设计 glitch free技术（一种防止毛刺产生的多路选择器设计）问题</p><p>无缝切换需要解决两个问题:<br>一是异步切换信号的<strong>跨时钟域同步</strong>问题，需要同步电路原理消除亚稳态；<br>二是同步好了的<strong>切换信号与时钟信号如何做逻辑</strong>，才能实现无毛刺。</p><p><strong>2.Glitch Free 技术原理</strong><br>下图显示了防止源时钟相互倍数的时钟开关输出出现毛刺的解决方案。<br>在每个时钟源的选择路径中插入一个<strong>负边沿触发的D触发器</strong>。 在时钟的下降沿采样选择控制（SELECT），以及仅在首先使其他时钟无效后使能选择（SELECT），可以提供出色的输出保护。<br><img src="https://img-blog.csdnimg.cn/20210503165725600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当SELECT为0时，明显CLK1的那部分通路到输出无效，仅仅看下半部分电路即可，在CLK0的下降沿采样SELECT（取反后）信号，与CLK0相与之后输出；<br>当SELECT为1时，同理上半部分电路有效；</p><p><strong>需要重点分析的是当SELECT在任意时刻切换的时候</strong>，输出会不会出现毛刺？<br>波形示意图如下所示，重点需要关注的是，只有当clk1下降沿采完SELECT变低之后，clk1的下降沿时钟才能开始采样上升沿，这类似与锁存器，先将select值锁存，等到clk1的边沿时，将值重新赋值；<br><img src="https://img-blog.csdnimg.cn/20210503171450545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2.Glitch Free  2-1MUX Verilog 实现</strong><br><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#96;timescale  1ns&#x2F;10psmodule  clock_mux (    &#x2F;&#x2F; OUTPUTs    output         clk_out,        &#x2F;&#x2F; Clock output        &#x2F;&#x2F; INPUTs    input          clk_in0,        &#x2F;&#x2F; Clock input 0    input          clk_in1,        &#x2F;&#x2F; Clock input 1    input          reset,            &#x2F;&#x2F; Reset    input          select_in       &#x2F;&#x2F; Clock selection);&#x2F;&#x2F;----------------------------------------&#x2F;&#x2F;  Regs declare&#x2F;&#x2F;----------------------------------------    reg   dff0a,dff0b;    reg   dff1a,dff1b;    &#x2F;&#x2F;----------------------------------------&#x2F;&#x2F;  clk_in0 path&#x2F;&#x2F;----------------------------------------&#x2F;&#x2F; negedge of clk_in0    always @(negedge clk_in0 or posedge reset)      if(reset)             dff0a &lt;&#x3D;  1&#39;b1;      else                dff0a &lt;&#x3D;  !select_in &amp; !dff1b;         always @(posedge clk_in0 or posedge reset)      if(reset)             dff0b &lt;&#x3D;  1&#39;b1;      else                dff0b &lt;&#x3D;  dff0a;         wire  clk_in0_gate  &#x3D; clk_in0 &amp; dff0b;&#x2F;&#x2F;----------------------------------------&#x2F;&#x2F;  clk_in1 path&#x2F;&#x2F;----------------------------------------&#x2F;&#x2F; negedge of clk_in1    always @(negedge clk_in1 or posedge reset)      if(reset)             dff1a &lt;&#x3D;  1&#39;b0;      else                dff1a &lt;&#x3D;  select_in &amp; !dff0b;         always @(posedge clk_in1 or posedge reset)      if(reset)             dff1b &lt;&#x3D;  1&#39;b0;      else                dff1b &lt;&#x3D;  dff1a;         wire  clk_in1_gate  &#x3D; clk_in1 &amp; dff1b;&#x2F;&#x2F;-----------------------&#x2F;&#x2F;  clock mux out&#x2F;&#x2F;-----------------------    assign  clk_out &#x3D; clk_in0_gate | clk_in1_gate;        endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>有关多路MUX参考这篇文章：<a href="https://blog.csdn.net/vivid117/article/details/105793469?spm=1001.2014.3001.5501">SOC设计——时钟切换的MUX设计 glitch free技术（一种防止毛刺产生的多路选择器设计）</a></p>]]></content>
      
      
      <categories>
          
          <category> Digital IC Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Verilog </tag>
            
            <tag> 无毛刺时钟MUX设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字IC设计8——verilog编写4（流水线握手协议）</title>
      <link href="/posts/91725775.html"/>
      <url>/posts/91725775.html</url>
      
        <content type="html"><![CDATA[<p>1 流水线与握手协议</p><p>流水线在电路设计过程中，是必不可少的一种实现方式，其可以提高电路的性能，当我们需要设计高速电路的时候，就需要用到流水线；</p><p>流水线的设计，就是指对延时较大的组合逻辑插入寄存器，把较大的组合逻辑拆分成几个时钟周期来完成，以提高系统的最大时钟频率。但是这样做，会导致数据输出的延时，假若插入一个寄存器，则数据输出就到产生一个时钟周期的延时，假若插入N个寄存器，就会产生N个时钟周期的延时；</p><p>而握手协议能够确保数据的上游和下游能够正确的接收数据，握手协议的原则是：当Valid和Ready信号同时高有效时，数据在时钟上升沿传输：</p><p><img src="https://img-blog.csdnimg.cn/2021043020545448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2 流水线握手协议的电路设计</p><p>下面主要介绍使用Verilog设计一个简单的Valid-Ready握手协议电路的基本原理</p><p>本设计可以实现数据的流入和数据的流出，这样一个双端口握手协议通道传输。Valid和Ready信号的原理类似于FIFO的读写和空满信号，就好像FIFO外边包了一层。<br><img src="https://img-blog.csdnimg.cn/20210430205537430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在FIFO的端口信号上加上如上图所示反相器，也可达到握手的效果。</p><p>Valid-Ready信号产生有两种情况</p><p>1.Ready-Before-Valid</p><p>Ready-Before-Valid是Ready信号在Valid信号之前有效。</p><p>这样设计使得在数据来临之前，通道已准备好接收数据，可以保持通道的最大吞吐量，因为Ready先产生，这个通道保持刷新等待数据。通道作为接受数据端采用这样的设计。</p><p>2.Valid-before-Ready</p><p>Valid-before-Ready是Valid信号在Ready信号之前有效。通道作为数据输出端采用这样的设计。收到下游接收端的准备接收信号，才开始传输数据。</p><p>Valid-Ready协议Stalemate情况</p><p>Stalemate可以理解为“锁住”。假设我们不遵守上面两种接收端和输出端的设计规则。</p><p>输出端用Ready-Before-Valid而接受端使用Valid-before-Ready，就会出现输出端等待接受端给出的Ready来输出数据，但是接收端也在等待输出端给出Valid信号来接受数据。两者都在等待却没有一方先给，所以这个时候这个通道就是无效的，被“锁住”了。</p><p>握手协议的几种连接情况</p><p><img src="https://img-blog.csdnimg.cn/20210430205557221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.握手流水线的Verilog设计（其中一级）</p><p><img src="https://img-blog.csdnimg.cn/20210430205611816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>前面说过握手协议的接口可以在同步FIFO的基础上加以修改，修改电路如图：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">assign  valid_o &#x3D; ~fifo_empty;assign  ready_o &#x3D; ~fifo_full;assign  wr_en &#x3D; ready_o &amp; valid_i;assign  rd_en &#x3D; ready_i &amp; valid_o；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210430205642652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>verilog实现代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">module Handshake_Protocol(input clk,input rst_n,input valid_i,  &#x2F;&#x2F;from pre-stageinput        data_i,  &#x2F;&#x2F;from pre-stageinput ready_i,  &#x2F;&#x2F;from post-stageoutput    ready_o,  &#x2F;&#x2F;to pre-stageoutput valid_o,  &#x2F;&#x2F;to post-stageoutput        data_o  &#x2F;&#x2F;to post-stage);reg  valid_o_r;reg   ready_o_r;reg   data_r;reg     dout;   always @(posedge clk or negedge rst_n) beginif(!rst_n) beginvalid_o_r &lt;&#x3D; 1&#39;b0;         data_r  &lt;&#x3D; 0;      endelse if(valid_i &amp;&amp; ready_o) beign        valid_o_r &lt;&#x3D; 1&#39;b1;         data_r  &lt;&#x3D; data_i;      end      elsevalid_o_r &lt;&#x3D; 1&#39;b0;endalways @(posedge clk or negedge rst_n)if(!rst_n) beginready_o_r &lt;&#x3D; 1&#39;b0;         dout  &lt;&#x3D; 0;endelse if(valid_o_r &amp;&amp; ready_i) begin        ready_o_r &lt;&#x3D; 1&#39;b1;          dout &lt;&#x3D; data_r;end      else        ready_o_r &lt;&#x3D; 1&#39;b0;   endassign ready_o &#x3D; ready_o_r;assign valid_o &#x3D; valid_o_r;assign data_o  &#x3D; dout;endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当vld_o为拉高时，表示这一级数据已经准备好，下一级数据可以将其读走；</p><p>当ready_o为拉高时，表示这几数据已经被读走，上一级数据可以写入新的数据；</p><p>此外，如果要实现高速的流水线作业，即这一级数据被读走时，上一级数据同时进来，这样每一级寄存器都会无缝的连接上（流水）；</p><p>但是上述RTL存在优先级问题，即数据没有被读走之前，不能被写入；</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">always @(posedge clk or negedge rst_n) beginif(!rst_n) beginvalid_o_r &lt;&#x3D; 1&#39;b0;         data_r  &lt;&#x3D; 0;      endelse if(valid_i &amp;&amp; ready_o) beign    &#x2F;&#x2F;数据可写进来，同时将valid_o置高，告诉下一级读取数据        valid_o_r &lt;&#x3D; 1&#39;b1;         data_r  &lt;&#x3D; data_i;      end      else if（valid_o_r &amp;&amp; ready_i）     &#x2F;&#x2F;如果数据读走之后，因此将valid_o拉低；valid_o_r &lt;&#x3D; 1&#39;b0;endalways @(posedge clk or negedge rst_n)if(!rst_n) beginready_o_r &lt;&#x3D; 1&#39;b0;         dout  &lt;&#x3D; 0;endelse if(valid_o_r &amp;&amp; ready_i) begin        ready_o_r &lt;&#x3D; 1&#39;b1;          dout &lt;&#x3D; data_r;end      else if (ready_o_r &amp;&amp; valid_i)        ready_o_r &lt;&#x3D; 1&#39;b0;   end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当该级ready_o与valid_i同时为高时，将valid拉高，表明数据已经被写入了，下一级可以读出；</p><p>有问题的欢迎指正！</p>]]></content>
      
      
      <categories>
          
          <category> Digital IC Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Verilog </tag>
            
            <tag> 流水线握手协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字IC设计7——verilog编写3（边沿检测）</title>
      <link href="/posts/91756769a2122666.html"/>
      <url>/posts/91756769a2122666.html</url>
      
        <content type="html"><![CDATA[<p>上升沿,下降沿检测电路，即针对输入信号的跳变进而输出判断结果，上升沿、下降沿可以分别进行寄存器打拍，而后相与或者相或；</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">module edge_detect(clk,rstn,signal_a,pos_edge_flag,neg_edge_flag);input             clk,rst;input             signal_a;output            pos_edge_flag, neg_edge_flag;reg signal_reg_1,signal_reg_2;&#x2F;&#x2F;syncalways @(posedge clk or negedge rstn) begin    if (!rstn)         &#123;signal_reg_2,signal_reg_1&#125; &lt;&#x3D; 2&#39;b00;    else         &#123;signal_reg_2,signal_reg_1&#125; &lt;&#x3D; &#123;signal_reg_1,signal_a&#125;;end&#x2F;&#x2F;pos_edge falg pull up        assign pos_edge_flag &#x3D; signal_reg_1 &amp; !signal_reg_2;&#x2F;&#x2F;neg_edge falg pull upassign neg_edge_flag &#x3D; !signal_reg_1 &amp; signal_reg_2;endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Digital IC Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Verilog </tag>
            
            <tag> 边沿检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字IC设计6——verilog编写2（如何优雅的写出分频器RTL设计）</title>
      <link href="/posts/91756769a2122.html"/>
      <url>/posts/91756769a2122.html</url>
      
        <content type="html"><![CDATA[<p>上一篇文章介绍了有关分频器的RTL设计，有细心的读者可以发现RTL代码并不完善，如何对RTL改进，优雅的写出RTL，让面试官对你的coding style有深刻的印象，并认为你的基础扎实；</p><p>下面先看这个例子：</p><p>使用Verilog语言编写7分频的RTL设计：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">module div_old_7(    &#x2F;&#x2F;define div &#x3D; N    input    clk,    input    rstn,    output   o_clk); parameter N &#x3D; 7;    reg    [2:0]  clk_cnt_pos, clk_cnt_neg;    reg          pos_clk, neg_clk; &#x2F;&#x2F;pos_edge clk cnt    always @(posedge clk ) begin        if (!rstn)            clk_cnt_pos &lt;&#x3D; 3&#39;b0;        else if (clk_cnt_pos &#x3D;&#x3D; N-1)            clk_cnt_pos &lt;&#x3D; 3&#39;b0;        else            clk_cnt_pos &lt;&#x3D; clk_cnt_pos + 1&#39;b1;    end    &#x2F;&#x2F;pos clk flag    always @(posedge clk ) begin    if (!rstn)          pos_clk &lt;&#x3D; 1&#39;b0;      else if (clk_cnt_pos &#x3D;&#x3D; N-1 )          pos_clk &lt;&#x3D; ~pos_clk;else if (clk_cnt_pos &#x3D;&#x3D; (N-1)&#x2F;2 - 1)          pos_clk &lt;&#x3D; ~pos_clk;    end &#x2F;&#x2F;neg_edge clk    always @(negedge clk ) begin      if (!rstn)         clk_cnt_neg &lt;&#x3D; 3&#39;b0;      else if (clk_cnt_neg &#x3D;&#x3D; N-1)         clk_cnt_neg &lt;&#x3D; 3&#39;b0;      else         clk_cnt_neg &lt;&#x3D; clk_cnt_neg + 1&#39;b1;    end    &#x2F;&#x2F;neg clk flag    always @(negedge clk ) begin    if (!rstn)          neg_clk &lt;&#x3D; 1&#39;b0;      else if (clk_cnt_neg &#x3D;&#x3D; N-1 )          neg_clk &lt;&#x3D; ~pos_clk;else if (clk_cnt_neg &#x3D;&#x3D; (N-1)&#x2F;2 - 1)          neg_clk &lt;&#x3D; ~neg_clk;    end    assign o_clk &#x3D; neg_clk | pos_clk;endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述RTL设计有如下问题：</p><p>采用同步复位带来的问题，虽然采用同步设计的思路，可以有效避免亚稳态，但是在FPGA或ASIC设计中，标准单元库中的寄存器一般均带有异步复位端的寄存器，如果大量采用这种设计，会带来额外的逻辑来确保功能正确；</p><p>采用两个上升沿always语句块与采用两个下降沿always语句块，其实在综合过程中也会在面积上有一定的增加；可以考虑将相同的功能块尽量放在一个always语句块中；</p><p>采用(N-1)/2的设计方法，也会带来面积上的增加的问题；</p><p>最后采用将时钟直接或逻辑的操作，虽然在功能上并不会带来问题，但是对于敏感时钟来说，毛刺可能会发生，因此，在实际设计应用中，需要确保产生的高质量的时钟；</p><p>优雅的写出7分频RTL设计：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">module div_old_7(    &#x2F;&#x2F;define div &#x3D; N    input    clk,    input    rstn,    output  reg  o_clk); parameter N &#x3D; 7; reg rstn_sync0,rstn_sync1; always @(posedge clk or negedge rstn) beginif (!rstn)        &#123;rstn_sync1,rstn_sync0&#125; &lt;&#x3D; 2&#39;b00;      else       &#123;rstn_sync1,rstn_sync0&#125; &lt;&#x3D;&#123;rstn_sync0,1&#39;b1,&#125;; end    reg    [2:0]  clk_cnt_pos, clk_cnt_neg;    reg          pos_clk, neg_clk;    always @(posedge clk or negedge rstn_sync1) begin        if (!rstn_sync1)  begin            clk_cnt_pos &lt;&#x3D; 0;            pos_clk     &lt;&#x3D; 1&#39;b0;        end        else  if (clk_cnt_pos &#x3D;&#x3D; N-1) begin            clk_cnt_pos &lt;&#x3D; 0;‘’            pos_clk     &lt;&#x3D; ~pos_clk;        end        else if (clk_cnt_pos &#x3D;&#x3D; (N-1) &gt;&gt; 1 - 1 ) begin            clk_cnt_pos &lt;&#x3D; clk_cnt_pos + 1&#39;b1;            pos_clk     &lt;&#x3D; ~pos_clk;        end        else            clk_cnt_pos &lt;&#x3D; clk_cnt_pos + 1&#39;b1;    end    always @(negedge clk or negedge rstn_sync1) begin        if (!rstn_sync1) begin            clk_cnt_neg &lt;&#x3D; 0;            neg_clk     &lt;&#x3D; 1&#39;b0;        end        else  if (clk_cnt_neg &#x3D;&#x3D; N-1) beign            clk_cnt_neg &lt;&#x3D; 0            neg_clk     &lt;&#x3D; ~neg_clk;        end        else if (clk_cnt_neg &#x3D;&#x3D; (N-1)&gt;&gt;1 - 1 ) begin            clk_cnt_neg &lt;&#x3D; clk_cnt_neg + 1&#39;b1;            neg_clk     &lt;&#x3D; ~neg_clk;        end        else            clk_cnt_neg &lt;&#x3D; clk_cnt_neg +1&#39;b1;    end always @(negedge clk or negedge rstn_sync1) begin        if (!rstn_sync1)          o_clk &lt;&#x3D; 1&#39;b0;        else          o_clk &lt;&#x3D; neg_clk | pos_clk; endendmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>喜欢作者的朋友们欢迎关注B站: <a href="https://space.bilibili.com/68137101">摆渡沧桑</a></p>]]></content>
      
      
      <categories>
          
          <category> Digital IC Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Verilog </tag>
            
            <tag> 分频器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字IC设计5——verilog编写1（分频器）</title>
      <link href="/posts/91756769a2.html"/>
      <url>/posts/91756769a2.html</url>
      
        <content type="html"><![CDATA[<p>本次介绍的主题是分频器的电路实现，包括偶数分频，奇数分频，以及任意整数的分频器的RTL编写；</p><p>直接进入主题</p><h3 id="1-偶数分频"><a href="#1-偶数分频" class="headerlink" title="1.偶数分频"></a>1.偶数分频</h3><p>首先给出任意偶数分频RTL（以6分频为例）（不完善的）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">module div_even #(parameter  N &#x3D; 6)(    &#x2F;&#x2F;define div &#x3D; N    input    clk,    input    rstn,    output   o_clk);    reg    [m:0]    cnt;     &#x2F;&#x2F;width m determined by N    reg     clk_o;    always @(posedge clk or negedge rstn) begin        if (!rstn) begin            cnt &lt;&#x3D; 0;            clk_out &lt;&#x3D; 1&#39;b0;        end        else if (cnt &#x3D;&#x3D; N&gt;&gt;2 - 1) begin            cnt &lt;&#x3D; 0;            clk_out &lt;&#x3D; ~clk_out;        end        else            cnt &lt;&#x3D; cnt + 1&#39;b1;    end    assign o_clk &#x3D; clk_out;endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：首先需要对时钟上升沿进行计数，每次计数到5时，计数清0，并且时钟翻转一次；</p><h3 id="2-奇数分频"><a href="#2-奇数分频" class="headerlink" title="2.奇数分频"></a>2.奇数分频</h3><p>任意奇数分频RTL（以7分频为例）（不完善的）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">module div_old #(parameter  N &#x3D; 7)(    &#x2F;&#x2F;define div &#x3D; N    input    clk,    input    rstn,    output   o_clk);    reg    [3:0]  clk_cnt_pos, clk_cnt_neg;    reg           pos_clk, neg_clk;    always @(posedge clk or negedge rstn) begin        if (!rstn)  begin            clk_cnt_pos &lt;&#x3D; 0;            pos_clk     &lt;&#x3D; 1&#39;b0;        end        else  if (clk_cnt_pos &#x3D;&#x3D; N-1) begin                &#x2F;&#x2F;计数到N-1翻转时钟，并且计数清0            clk_cnt_pos &lt;&#x3D; 0;‘’            pos_clk     &lt;&#x3D; ~pos_clk;        end        else if (clk_cnt_pos &#x3D;&#x3D; (N-1) &gt;&gt; 1 - 1 ) begin    &#x2F;&#x2F;计数到(N-1)&#x2F;2-1翻转时钟，不清0            clk_cnt_pos &lt;&#x3D; clk_cnt_pos + 1&#39;b1;            pos_clk     &lt;&#x3D; ~pos_clk;        end        else            clk_cnt_pos &lt;&#x3D; clk_cnt_pos + 1&#39;b1;    end    always @(negedge clk or negedge rstn) begin        if (!rstn) begin            clk_cnt_neg &lt;&#x3D; 0;            neg_clk     &lt;&#x3D; 1&#39;b0;        end        else  if (clk_cnt_neg &#x3D;&#x3D; N-1) beign            clk_cnt_neg &lt;&#x3D; 0            neg_clk     &lt;&#x3D; ~neg_clk;        end        else if (clk_cnt_neg &#x3D;&#x3D; (N-1)&gt;&gt;1 - 1 ) begin            clk_cnt_neg &lt;&#x3D; clk_cnt_neg + 1&#39;b1;            neg_clk     &lt;&#x3D; ~neg_clk;        end        else            clk_cnt_neg &lt;&#x3D; clk_cnt_neg +1&#39;b1;    end    assign o_clk &#x3D; neg_clk | pos_clk;endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：需要两个计数器、两个标志信号；计数器分别对时钟上升沿和下降沿进行计数，每次计数到N-1 (6)时，计数清零，其次需要两个标志信号，当计数器分别计数到(N-1)/2 -1 与N-1时，标志翻转，这样即可以得到占空比为（（N-1）-1）/ 2N的波形，最后将得到的两个标志信号逻辑或，即可以初步得到奇数分频时钟；</p><h3 id="3-任意整数分频"><a href="#3-任意整数分频" class="headerlink" title="3.任意整数分频"></a>3.任意整数分频</h3><p>任意整数分频RTL（不完善的）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">module div_N (    input CLK, &#x2F;&#x2F; 基准时钟    output CLK_div_N, &#x2F;&#x2F; N分频后得到的时钟    input rst);wire [31:0] N&#x3D;5;&#x2F;******************** 产生备用时钟1 ***************&#x2F;reg [31:0] cnt1; reg CLK_div_N_1;always @ (posedge CLK or negedge rst) begin    if(!rst) begin        cnt1 &lt;&#x3D; 0;        CLK_div_N_1 &lt;&#x3D; 0;    end    else if(N[0]&#x3D;&#x3D;0) &#x2F;&#x2F; 如果N为偶数，比N%2&#x3D;&#x3D;0这种判断方式更节省资源    begin        if(N &#x3D;&#x3D; 2) &#x2F;&#x2F; 如果N为2            CLK_div_N_1 &lt;&#x3D; ~CLK_div_N_1;        else if(cnt1 &#x3D;&#x3D; ((N-2)&gt;&gt;1))        begin            cnt1 &lt;&#x3D; 0;            CLK_div_N_1 &lt;&#x3D; ~ CLK_div_N_1;        end        else            cnt1 &lt;&#x3D; cnt1 + 1&#39;b1;    end    else begin  &#x2F;&#x2F; 如果N为奇数        if(cnt1 &#x3D;&#x3D; N-1)        begin            CLK_div_N_1 &lt;&#x3D; ~CLK_div_N_1;            cnt1 &lt;&#x3D; 0;        end        else if(cnt1&#x3D;&#x3D;(N-1)&#x2F;2) begin            cnt1 &lt;&#x3D; cnt1 + 1&#39;b1;            CLK_div_N_1 &lt;&#x3D; ~CLK_div_N_1;        end        else            cnt1 &lt;&#x3D; cnt1 + 1&#39;b1;    endend&#x2F;*********************** 产生备用时钟2 *********************&#x2F;wire CLK0&#x3D;(N[0] &#x3D;&#x3D; 1&#39;b0) ? (~CLK):0; &#x2F;&#x2F; 如果N为偶数，备用时钟2（CLK_div_N_2）恒为0，即不需要用到此备用时钟reg [31:0] cnt2;reg CLK_div_N_2;always @ (posedge CLK0 or negedge rst) begin        &#x2F;&#x2F;相当于CLK下降沿    if(!rst) begin        cnt2 &lt;&#x3D; 0;        CLK_div_N_2 &lt;&#x3D; 0;    end    else if(cnt2 &#x3D;&#x3D; (N-1)&#x2F;2) begin        CLK_div_N_2 &lt;&#x3D; ~CLK_div_N_2;        cnt2 &lt;&#x3D; cnt2 + 1;    end    else if(cnt2&#x3D;&#x3D;N-1) begin        cnt2 &lt;&#x3D; 0;        CLK_div_N_2 &lt;&#x3D; ~CLK_div_N_2;    end    else        cnt2 &lt;&#x3D; cnt2+1;end&#x2F;******************** 产生最终分频时钟************************&#x2F;assign CLK_div_N &#x3D; CLK_div_N_1 | CLK_div_N_2;endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：该RTL实际将偶数分频与奇数分频进行了合并，并使用MUX来判断奇数和偶数的分频模式；</p>]]></content>
      
      
      <categories>
          
          <category> Digital IC Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Verilog </tag>
            
            <tag> 分频器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字IC设计2——跨时钟域篇2（亚稳态）</title>
      <link href="/posts/null.html"/>
      <url>/posts/null.html</url>
      
        <content type="html"><![CDATA[<p>数字IC设计——跨时钟域篇2（亚稳态）</p><h3 id="一、建立时间与保持时间"><a href="#一、建立时间与保持时间" class="headerlink" title="一、建立时间与保持时间"></a>一、建立时间与保持时间</h3><p><strong>前提条件</strong>：==对任何一种触发器，在时钟触发沿前、后的一个小时间窗口内，输入信号必须稳定。==<br><img src="https://img-blog.csdnimg.cn/20210604185557901.png" alt="在这里插入图片描述"></p><p>输入信号应提前时钟上升沿 （假设上升沿有效）T时间到达芯片，这个T就是<strong>建立时间Setup time</strong>。<br><img src="https://img-blog.csdnimg.cn/20210604185650624.png" alt="在这里插入图片描述"></p><p><strong>保持时间</strong>是指触发器的时钟信号上升沿到来以后，数据稳定不变的时间。<br><img src="https://img-blog.csdnimg.cn/20210604185838816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="二、亚稳态"><a href="#二、亚稳态" class="headerlink" title="二、亚稳态"></a>二、亚稳态</h3><ol><li>亚稳态<br>触发器无法在某个规定的时间段内，达到一个可确认的状态。亚稳态会带来功能的错误。<br><img src="https://img-blog.csdnimg.cn/20210604190313364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><pre><code>当发生亚稳态时，既无法预测该单元的输出电平，也无法预测何时才能稳定在某个正确的电平上。</code></pre><ol><li>亚稳态传播<br>这种无用的输出电平可以沿信号通道上的各个触发器级联的方式传播下去。<br><img src="https://img-blog.csdnimg.cn/20210604190351413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h3 id="三、如何处理亚稳态"><a href="#三、如何处理亚稳态" class="headerlink" title="三、如何处理亚稳态"></a>三、如何处理亚稳态</h3><ol><li><p><strong>如何处理亚稳态？</strong><br>1.降低系统时钟（基于建立时间，适当降低系统频率来满足时序约束）</p><p> 2.用反应更快的FF</p><p> 3.引入<strong>同步机制</strong>，防止亚稳态传播</p><p> 4.改善时钟质量，用边沿变化快速的时钟信号</p></li></ol><ol><li><strong>二级寄存器</strong><br>使用<strong>同步器降低亚稳态发生的概率</strong><br>1.亚稳态需要一段时间才能到达稳态<br>2.二级寄存器可以<strong>增加一个clock cycle</strong>的时间使亚稳态稳定<br><img src="https://img-blog.csdnimg.cn/20210604195226263.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210604195243166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>MTBF</li></ol><p>MTBF—-Mean Time Between Failure<br>平均故障间隔时间<br>两级同步<strong>并不能完全</strong>隔离亚稳态危害，但<strong>极大降低</strong>了亚稳态发生概率。\</p><p><img src="https://img-blog.csdnimg.cn/20210604201931622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用同步器降低亚稳态发生概率<br><img src="https://img-blog.csdnimg.cn/20210604202443582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>对于二级触发器，480MHz的频率比1000MHz频率的寿命要长很多；</li><li>对于1000MHZ，三级触发器要比二级触发器寿命长</li></ol><p>设计时可以参考上表，如果设计的时钟频率比较高，建议采用三级触发器同步的方式。</p><h3 id="四、亚稳态常见问题"><a href="#四、亚稳态常见问题" class="headerlink" title="四、亚稳态常见问题"></a>四、亚稳态常见问题</h3><h5 id="1-亚稳态的二级处理（增加一个clock-cycle的时间）"><a href="#1-亚稳态的二级处理（增加一个clock-cycle的时间）" class="headerlink" title="1. 亚稳态的二级处理（增加一个clock cycle的时间）"></a>1. <strong>亚稳态的二级处理（增加一个clock cycle的时间）</strong></h5><ol><li>亚稳态是指信号跳变时，由于<strong>不满足建立保持时间</strong>，寄存器的输出端会输出中间电平，或者产生震荡等。亚稳态<strong>不是一个持续的状态</strong>，是一个短暂的状态。</li><li>对于异步信号，<strong>一级寄存器永远会有亚稳态的可能</strong>。</li><li>如果第一级寄存器出现亚稳态，<strong>亚稳态的时间如果在1个clock cycle之内恢复了，那么第二级寄存器会采样到稳定状态</strong>。如果亚稳态时间过于长超过1个clock cycle，那么第二级仍然有可能输出亚稳态。</li><li>亚稳态不是纠错，如果产生亚稳态，那么采样值可能是不正确的，<strong>两级寄存器或者多级寄存器的级联</strong>是防止亚稳态状态在时序电路中<strong>传播扩散</strong>。</li></ol><h5 id="2-增加寄存器避免亚稳态，但这能保证输出逻辑是正确的么？"><a href="#2-增加寄存器避免亚稳态，但这能保证输出逻辑是正确的么？" class="headerlink" title="2. 增加寄存器避免亚稳态，但这能保证输出逻辑是正确的么？"></a>2. 增加寄存器避免亚稳态，但这能保证输出逻辑是正确的么？</h5><p><strong>增加寄存器可以避免亚稳态传播，但是不能纠正逻辑正确性</strong>。<br><strong>多级寄存器</strong>可以保证最后一级能够<strong>采样到稳定的值</strong>。但不一定能够采样到正确值。</p>]]></content>
      
      
      <categories>
          
          <category> Digital IC Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨时钟域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字IC设计3——跨时钟域篇3（单比特处理）</title>
      <link href="/posts/91756769.html"/>
      <url>/posts/91756769.html</url>
      
        <content type="html"><![CDATA[<p>数字IC设计——跨时钟域篇3（单比特处理）</p><p>下面介绍常见的单比特跨时钟域的处理方法</p><h3 id="一、慢时钟域信号同步到快时钟域的处理方法："><a href="#一、慢时钟域信号同步到快时钟域的处理方法：" class="headerlink" title="一、慢时钟域信号同步到快时钟域的处理方法："></a>一、慢时钟域信号同步到快时钟域的处理方法：</h3><ol><li><p><strong>两级寄存器同步</strong><br>慢时钟信号进入到更快的时钟域时（频率相差2倍以上），此时不用考虑快时钟域信号采样丢失问题，可以考虑使用<strong>两级触发器</strong>进行同步处理。</p></li><li><p><strong>边沿检测同步器</strong><br>慢时钟信号进入到更快的时钟域时（频率相差2倍以上）,为了避免快时钟域多次采样到有效信号，快时钟需要对信号进行边沿检测。需要使用<strong>边沿检测同步器</strong></p></li><li><p><strong>握手处理</strong>（单比特比较少用）<br>当一个慢时钟域的单比特信号进入到更快的时钟域，但是两个时钟频率相差不大（频率相差2倍以下），为了避免快时钟采样丢失，需要进行<strong>握手的同步处理</strong></p></li></ol><h3 id="二、边沿检测"><a href="#二、边沿检测" class="headerlink" title="二、边沿检测"></a>二、边沿检测</h3><p>之前说了如果慢时钟信号进入快时钟域信号，并且频率相差较大，那么快时钟域可以一直采样到慢时钟域信号，为了只在上升沿和下降沿或者双边沿采样到值，因此需要使用到<strong>边沿检测同步器</strong>。</p><p>之前写过一篇博客，可以参考：<br><a href="https://blog.csdn.net/vivid117/article/details/90757350?spm=1001.2014.3001.5501">FPGA基础入门篇(四) 边沿检测电路</a><br><a href="https://blog.csdn.net/vivid117/article/details/116153790?spm=1001.2014.3001.5501">数字IC设计verilog编写——3边沿检测</a></p><ol><li>上升沿检测<br>快时钟先将输入信号进行两级同步处理，再进行一个时钟的延迟，延迟后的信号取反与同步信号做与逻辑，得到信号的上升沿。<br><img src="https://img-blog.csdnimg.cn/20210605102136708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><ol><li>下降沿检测<br>快时钟先将输入信号进行两级同步处理，再进行一个时钟的延迟，延迟后的信号与取反后同步信号做与逻辑，得到脉冲信号的下降沿。<br><img src="https://img-blog.csdnimg.cn/20210605111038746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><ol><li>双沿检测<br>快时钟先将输入信号进行两级同步处理，再进行一个时钟的延迟，延迟后的信号与同步信号做异或逻辑，就可得到信号的双沿脉冲。<br><img src="https://img-blog.csdnimg.cn/20210605111428752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><ol><li>边沿检测的verilog RTL代码：</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">module edge_detect(clk,rstn,signal_a,pos_edge_flag,neg_edge_flag,double_edge_flag);input             clk,rst;input             signal_a;output            pos_edge_flag, neg_edge_flag,double_edge_flag;reg signal_reg_1,signal_reg_2,signal_reg_3;&#x2F;&#x2F;syncalways @(posedge clk or negedge rstn) begin    if (!rstn)         &#123;signal_reg_3,signal_reg_2,signal_reg_1&#125; &lt;&#x3D; 3&#39;b000;    else         &#123;signal_reg_3,signal_reg_2,signal_reg_1&#125; &lt;&#x3D; &#123;signal_reg_2,signal_reg_1,signal_a&#125;;end&#x2F;&#x2F;pos_edge falg pull up        assign pos_edge_flag &#x3D; signal_reg_2 &amp; !signal_reg_3;&#x2F;&#x2F;neg_edge falg pull upassign neg_edge_flag &#x3D; !signal_reg_2 &amp; signal_reg_3;&#x2F;&#x2F;double_edge flag assign double_edge_flag &#x3D; signal_reg_2 ^ signale_reg_3;endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：<br>在跨时钟域处理时，首先对单比特信号进行<strong>二级同步</strong>的处理得到稳定的信号，然后<strong>第三级在处理边沿检测</strong>。<strong>总共需要三拍的操作</strong>。</p><h3 id="三、快时钟域到慢时钟域处理方法"><a href="#三、快时钟域到慢时钟域处理方法" class="headerlink" title="三、快时钟域到慢时钟域处理方法"></a>三、快时钟域到慢时钟域处理方法</h3><p>快时钟域信号同步到慢时钟域的处理方法：</p><ol><li><p><strong>电平拓展</strong><br>如果已知慢时钟域的时钟频率，可以考虑将快时钟域的信号进行电平扩展，使得足以被慢时钟域采样。</p></li><li><p><strong>脉冲同步器</strong><br>快时钟域中需要同步的信号是脉冲信号，它出发原时钟域的<strong>翻转电路</strong>，每当翻转电路时，电路被翻转一次，慢时钟域的同步器对翻转后的信号进行采样，和边沿检测，再重新在本时钟域<strong>恢复出脉冲信号</strong>。</p><p> 具体RTL设计可以参考之前写的一篇博客：<br><a href="https://blog.csdn.net/vivid117/article/details/117589926?spm=1001.2014.3001.5501">数字IC设计verilog编写——6脉冲同步器</a></p><p> 脉冲同步器的原理结构图：<strong>翻转电路 + 边沿检测电路</strong><br>局限性：<br>1.脉冲需要是<strong>单脉冲信号</strong><br>2.多个脉冲之间需要<strong>大于两个</strong>需要同步时钟域周期以上（边沿检测）。如果小于2个周期，可能最终的信号恢复出来的高电平脉冲<strong>连在一起或者重叠为一个周期</strong>。<br>3.不能用在快时钟域采样慢时钟域<br><img src="https://img-blog.csdnimg.cn/20210605113448515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol><ol><li><strong>握手处理</strong>（稳定可靠，不管是单比特还是多比特，均可采用）<br>当一个快时钟的单比特信号进入到慢时钟域，同样可以使用握手的方式进行同步处理。</li></ol><h3 id="四、典型电路"><a href="#四、典型电路" class="headerlink" title="四、典型电路"></a>四、典型电路</h3><ol><li>跨时钟域的<strong>多个相关连的单比特信号不可以通过打拍的方式同步到目的时钟域</strong>。<br>对跨时钟域的<strong>timing path</strong>如果不处理，容易导致亚稳态。<br>如果做了同步处理，但同步处理不当俨然会出现glitch，多路扇出问题，re-convergence，datahold等问题导致电路实际运行出现故障。</li></ol><p><img src="https://img-blog.csdnimg.cn/20210605115607968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>CLKA domain中，DA1和DA2分别为两个DFF的输出，理想状态下，DA1和DA2到达与门两个输入端的时间是一样的，这样设计就不会出现问题。<br>但是<strong>后端布局环境等因素</strong>，导致的传播延迟Td会使A&amp;B存在一个glitch（<strong>信号到达与门的时间不一致</strong>）。而由于CLKB和CLKA为两个CLK Domain，之间不存在固定的相位关系，假设这个glitch恰好被CLKB锁存住，那么就会在DB2生成一个有效的高电平信号，这个高电平信号不是我们的设计所期望的，那就会导致后续的电路功能出现问题。</p><p>跨时钟域的多个相关联的单比特信号不可以通过打拍的方式同步到目的时钟域。<br><strong>错误使用方法</strong>:（异步单bit控制信号组合逻辑输出的错误使用）<br><img src="https://img-blog.csdnimg.cn/20210605154300635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>正确的解决方案（在原来时钟域先进行打拍处理）：<br><img src="https://img-blog.csdnimg.cn/20210605154718289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Digital IC Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨时钟域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字IC设计4——跨时钟域篇4（多比特处理）</title>
      <link href="/posts/91756769a2.html"/>
      <url>/posts/91756769a2.html</url>
      
        <content type="html"><![CDATA[<p>数字IC设计——跨时钟域篇4（多比特处理）</p><h3 id="一、-两级触发器的问题"><a href="#一、-两级触发器的问题" class="headerlink" title="一、 两级触发器的问题"></a>一、 两级触发器的问题</h3><ol><li><strong>两级触发器存在的问题</strong><br>如果简单的按照单比特信号穿越方法各bit打两拍单独穿越，则会造成<strong>各个bit穿越时间不一致</strong>（寄存器对于每个信号的延迟时间不一样），则会造成另一个时钟域里面有一些被前一个时钟沿采到了，有些被后面的采到了，导致目的时钟域采到的值错误，造成中间态无意义的数据。<br><img src="https://img-blog.csdnimg.cn/20210605215500869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>解决多比特跨时钟域方法</li></ol><ul><li>如果多比特信号之间存在逻辑关联性，可以在源时钟域将信号合成一个单一的控制信号，然后进行两级寄存器同步。<br>下左图是错误的处理方式，右图是正确的处理方式；<br><img src="https://img-blog.csdnimg.cn/2021060522084356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>RTL 代码</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">module twobits_cdc (  input  clka ,  input  clkb ,  input  rst_n,  input  lden  ,  input  load  ,  output a_lden  );reg b_lden;reg b_load;reg b_lden;reg a_lden;reg a_d;always@(posedge clkb or  negedge rst_n) begin  if (!rst_n)     b_lden &lt;&#x3D; 0;    b_load &lt;&#x3D; 0;  else     b_lden &lt;&#x3D; lden;    b_load &lt;&#x3D; load;endalways@(posedge clka or negedge rst_n) begin  if (!rst_n) begin    a_d &lt;&#x3D; 0;    a_lden  &lt;&#x3D; 0;    b_lden &lt;&#x3D; 0;  end  else  begin  b_lden &lt;&#x3D; b_load &amp; b_lden ;    a_d &lt;&#x3D; b_lden;    a_lden &lt;&#x3D; a_d;  endendendmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、多比特信号跨时钟域的处理方法"><a href="#二、多比特信号跨时钟域的处理方法" class="headerlink" title="二、多比特信号跨时钟域的处理方法"></a>二、多比特信号跨时钟域的处理方法</h3><ol><li><p><strong>格需码编码</strong><br>通过编码的方式将多位信号转化为每次只有一位变化的信号，将“多比特”的跨时钟域变换成“单比特”进行处理。</p></li><li><p><strong>异步FFO</strong><br>异步FIFO融合了<strong>寄存器同步，格雷码编码，握手控制</strong>等处理方式，是处理跨时钟域数据传输最常用的方式。</p></li><li><p><strong>握手处理</strong><br>所谓握手，是指通信双方使用了专用控制信号进行数据收发的状态指示。<strong>这个控制信号既有发送域给接收域的，也有接收域给发送域的，有别于前面的单向控制信号检测方式</strong>。类似于DMA与外设模块的通信，会用到dma_req,dma_ack</p></li></ol><h3 id="三、格雷码转换"><a href="#三、格雷码转换" class="headerlink" title="三、格雷码转换"></a>三、格雷码转换</h3><p>格雷码可以通过算法与二进制编码进行相互转换，相邻两个编码之间只有一位不同。</p><ol><li><strong>格雷码</strong>是一种特殊的二进制编码方式，在一定程度上优于二进制编码</li><li>可以<strong>通过算法与二进制编码</strong>进行<strong>相互转换</strong></li><li>相邻两个编码之间<strong>只有一位不同</strong><br><img src="https://img-blog.csdnimg.cn/20210605222658555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Digital IC Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨时钟域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字IC设计1——跨时钟域篇1（概述）</title>
      <link href="/posts/9.178982e+84.html"/>
      <url>/posts/9.178982e+84.html</url>
      
        <content type="html"><![CDATA[<p>数字IC设计——跨时钟域篇1</p><h3 id="一、时钟域概要"><a href="#一、时钟域概要" class="headerlink" title="一、时钟域概要"></a>一、时钟域概要</h3><h5 id="1-CDC介绍"><a href="#1-CDC介绍" class="headerlink" title="1. CDC介绍"></a>1. CDC介绍</h5><p><strong>CDC</strong>（clock domain crossing）检查（跨时钟域的检查）是对电路设计中<strong>同步电路设计</strong>的检查。非同步时钟没有固定的相位关系，这样Setup/Hold不满足而产生了亚稳态是无法避免的。我们<strong>采用同步设计的方法保证亚稳态不会无序的在电路中传播</strong>，从而导致功能问题。</p><p>随着当今SOC设计的规模越来越大，时钟越来越多，工作模式越来越复杂。<strong>跨时钟域电路不但多，而且非常复杂</strong>。 在当今的电路设计中我们通常使用<strong>多级同步，异步FIFO，握手等同步设计</strong>来保证亚稳态信号不会在电路中无序的传播。</p><p>但同步设计中，<strong>同步处理不当依然会出现glitch</strong>、<strong>多路扇出</strong>等问题导致电路实际运行出现故障。</p><p>目前我们的数字设计大部分是基于RTL设计的，直接通过RTL检查”跨时钟域的同步设计” 很难做到100%覆盖的检查，特别是当今SOC中集成大量IP，直接通过RTL检查几乎不可能的。 <strong>电路设计中同步电路设计的检查都是使用专门的EDA工具做静态的CDC检查</strong>。</p><p>常用的<strong>CDC检查工具</strong>有<strong>Conformal CDC</strong> 和 <strong>Spyglass CDC</strong>。</p><p>此外CDC检查也是前端sign off 重要项目和数字IC设计工程师的必备的技能。</p><h3 id="二、-时钟介绍"><a href="#二、-时钟介绍" class="headerlink" title="二、 时钟介绍"></a>二、 时钟介绍</h3><ol><li><strong>时钟属性</strong><br><img src="https://img-blog.csdnimg.cn/20210604111745366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><pre><code>时钟信号是一个按一定电压幅度，**一定时间间隔连续发出的脉冲信号**。脉冲信号之间的时间间隔称为**周期**；单位时间（如1秒）内所产生的脉冲个数称为**频率**。频率的标准计量单位是Hz（赫）。数字芯片中众多的晶体管工作在开关状态，它们的导通和关断动作无不是按照时钟信号的节奏进行的。</code></pre><ol><li><strong>时钟偏斜（Skew）</strong><br>时钟偏斜指的是同一个时钟信号到达两个不同寄存器之间的时间差值，<strong>skew的定义就是最长路径与最短路径差值</strong>。<br><img src="https://img-blog.csdnimg.cn/20210604112320215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>时钟抖动（jitter）</strong><br>抖动，即指两个时钟周期之间存在的差值，这个误差是在时钟发生器内部产生的，和晶振或者PLL内部电路有关系<br><img src="https://img-blog.csdnimg.cn/20210604112528723.png" alt="在这里插入图片描述"><br>刻画时钟偏斜和时钟抖动，即时钟的不确定性：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">set_clock_uncertainty Tu [get_clock CLK]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，Tu即为时钟偏斜和抖动的和值。通过后端工程师与PLL相关值来确定。</p><h3 id="三、-时钟源"><a href="#三、-时钟源" class="headerlink" title="三、 时钟源"></a>三、 时钟源</h3><ol><li><p>数字电路里一般用<strong>晶振</strong>提供基本的时钟信号。<br>从一块二氧化硅晶体上按一定的方位角切下薄片(称为“晶片”)，在晶片的两个表面上涂覆一层薄薄的银层后接上一对金属板，焊接引脚，并用金属外壳封装，就构成了<strong>石英晶体振荡器</strong>（OSC）——基于压电效应。<br><img src="https://img-blog.csdnimg.cn/20210604113626632.png" alt="在这里插入图片描述"></p></li><li><p>有些芯片的一部分时钟来自于其他芯片。它的时钟源就是外部芯片的输出信号。如SPI，I2C接口就来自外部芯片。</p></li></ol><p>一个时钟源的例子：<br><img src="https://img-blog.csdnimg.cn/2021060411371367.png" alt="在这里插入图片描述"><br>电路中有存在其他模块的时钟源CLKA与振荡器CLK_OSC两个时钟源。</p><h3 id="四、-同步时钟"><a href="#四、-同步时钟" class="headerlink" title="四、 同步时钟"></a>四、 同步时钟</h3><ol><li>同步时钟：<br>a.同源，比如分频电路<br>b.有固定的相位关系<br><img src="https://img-blog.csdnimg.cn/2021060411414591.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210604114125536.png" alt="在这里插入图片描述"></li><li><p>不同步时钟：<br><img src="https://img-blog.csdnimg.cn/20210604114219599.png" alt="在这里插入图片描述"><br>如果C1与C2来自不同的晶振，那么就是不同步的时钟</p></li><li><p>ASIC中时钟结构<br>MCU内部时钟结构图：<br><img src="https://img-blog.csdnimg.cn/20210604114524989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图中一个8MHz的时钟源OSC_IN经过PLL倍频之后，由无毛刺的MUX选择器选择时钟，在经由分频器，分频出一系列频点的时钟，最后经过ICG门控开关，由OCC（on chip controller）来控制选择那一路时钟，分配test模式和function模式。</p></li></ol><p><strong>CTS（clock tree synthesize）</strong><br><img src="https://img-blog.csdnimg.cn/20210604115047412.png" alt="在这里插入图片描述"><br>ASIC设计时，时钟分布是一个网状结构，为了能够达到时钟到达每个寄存器的路径误差不大，可以利用CTS来确保源头的时钟到达各寄存器延迟差不多。</p><ol><li>FPGA中时钟结构<br>FPGA中的时钟和ASIC时钟结构基本相似。在ASIC中，定制化的通过后端的工具插入clock tree以及其他功能。但是在FPGA中，这些驱动和链接资源已经是做好的，只能利用这些，用这些功能来完成时钟的分配。</li></ol><p>以Xilinx 7系列的时钟为例：</p><ul><li><strong>MMCM</strong>（Mixed-Mode Clock Manager）混合模式时钟管理器</li><li>High-Performance Clock</li><li><strong>BUFG</strong>（全局时钟缓冲器）：驱动FPGA全局时钟驱动</li><li><strong>BUFH</strong>（horizontal clock buffers横向Bank时钟缓冲器）：局部时钟区域驱动</li><li><strong>BUGR</strong> （纵向Bank时钟缓冲器）：局部区域时钟驱动</li><li><strong>BUFMR</strong> （multi-clock region buffers）：驱动多个时钟域</li><li><strong>BUFIO</strong> （用于IO输出缓冲）：BUFH和BUFR也可以驱动BUFIO</li></ul><p><img src="https://img-blog.csdnimg.cn/20210604120141836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>MMCM结构图：<br><img src="https://img-blog.csdnimg.cn/20210604120237523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在实际设计中，需要充分考虑有多少时钟资源。来驱动相关的逻辑电路<br>对于ASIC设计，如何将其设计转到FPGA中：<br>ASIC设计中有很多同源时钟，但是很多均跨越多个时钟域，但是考虑布局布线，我们将这些同源时钟关系做一些异步处理。代价是增加面积来获取快的开发时间。<br>或者直接利用MMCM产生ASIC设计中所需的时钟，在通过添加BUFG。</p><h3 id="五、-异步时钟"><a href="#五、-异步时钟" class="headerlink" title="五、 异步时钟"></a>五、 异步时钟</h3><p>异步时钟<br>1.不同源<br>2.没有固定的相位关系</p><p><img src="https://img-blog.csdnimg.cn/20210604121550655.png" alt="在这里插入图片描述"><br>CLKA与CLKA_div2是同步时钟<br>CLKA与CLK_OSC是异步时钟</p><p>考虑两种情况：</p><ol><li>对于不同频率的时钟如100M,99M的两个时钟，不一定为异步时钟，即如果来自同一个源，那么即为<strong>同步时钟</strong><br><img src="https://img-blog.csdnimg.cn/20210604121755635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>如果频率相同，没有固定的相位关系。是否为不同时钟，答案也不一定是同步时钟。如果相位不同，即使频率相同，仍然是<strong>异步时钟</strong>。<br><img src="https://img-blog.csdnimg.cn/20210604121905844.png" alt="在这里插入图片描述"><h3 id="六、时钟域"><a href="#六、时钟域" class="headerlink" title="六、时钟域"></a>六、时钟域</h3>时钟域（Clock Domain） <strong>以捕获时钟划分时钟域</strong></li><li><p><strong>单时钟域</strong>：数据发送和接收<strong>是</strong>同一个时钟<br><img src="https://img-blog.csdnimg.cn/20210604164043289.png" alt="在这里插入图片描述"></p></li><li><p><strong>多时钟域</strong>：数据发送和接收<strong>不是</strong>同一个时钟<br><img src="https://img-blog.csdnimg.cn/20210604164118551.png" alt="在这里插入图片描述"><br>对于改电路，以FB捕获<strong>C2时钟为该电路时钟</strong>。</p><p> 注意<strong>capture时钟</strong>和<strong>launch时钟</strong>的相对定义</p></li></ol><h3 id="七、跨时钟域问题"><a href="#七、跨时钟域问题" class="headerlink" title="七、跨时钟域问题"></a>七、跨时钟域问题</h3><ol><li><p><strong>跨时钟域</strong><br>若一个电路<strong>launch时钟</strong>和<strong>capture时钟</strong>不是同一个时钟，就是跨时钟域电路</p><p> 若两个时钟是<strong>同步时钟</strong>就是<strong>同步时钟域</strong><br> 若两个时钟是<strong>异步时钟</strong>就是<strong>异步时钟域</strong></p><p> 例子：<br><img src="https://img-blog.csdnimg.cn/20210604164754100.png" alt="在这里插入图片描述"><br>lanch时钟为CLKA，capture时钟为CLKB，该电路为典型的跨时钟域的例子。<br>跨时钟例子：<br>单个模块：UART, USB等</p></li><li><p><strong>跨时钟域问题</strong><br><img src="https://img-blog.csdnimg.cn/20210604170052941.png" alt="在这里插入图片描述"><br>CLK1与CLK2来自不同时钟源，由于时钟源不同，对于REG2和REG3来说，在同一时刻，一个认为REG1的输出是1，另一个认为是0，这将会导致电路判断出现错误，即亚稳态问题。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Digital IC Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨时钟域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMBA总线协议（五）—— AXI3 协议接口信号介绍1</title>
      <link href="/posts/917253435abaaa111.html"/>
      <url>/posts/917253435abaaa111.html</url>
      
        <content type="html"><![CDATA[<ol><li><a href="https://blog.csdn.net/vivid117/article/details/107511746">AMBA总线协议（一）—— 一文看懂APB总线协议</a></li><li><a href="https://blog.csdn.net/vivid117/article/details/110235612">AMBA总线协议（二）—— 一文看懂AMBA2 AHB2与AMBA3 AHB-Lite总线协议的区别</a></li><li><a href="https://blog.csdn.net/vivid117/article/details/110501631">AMBA总线协议（三）—— 一文看懂AHB总线所有协议总结（AHB2 &amp; AHB-Lite &amp; AHB5 ）</a></li><li><a href="https://blog.csdn.net/vivid117/article/details/110673909">AMBA总线协议（四）—— Multi-Layer AHB System (多层AHB总线架构)</a></li><li><a href="https://blog.csdn.net/vivid117/article/details/110871257">AMBA总线协议（五）—— AXI3 协议接口信号介绍1</a><h4><span id="1-axi-协议介绍">1. AXI 协议介绍：</span></h4><h6><span id="a-axi协议">a. AXI协议</span></h6></li><li>AMBA AXI协议主要用于高性能，高频率系统设计，并且有很多特性支持AXI可以应用于高速的互连架构</li><li>最新AMBA 接口（指AXI 3）主要目标：</li></ol><pre class="line-numbers language-none"><code class="language-none">1) 高带宽、低延迟的设计2) 不需要桥接器就可以工作在高频 3) 满足更广的组件接口的要求4) 很适合具有初始化延迟高的内存控制器5) 灵活性，在互连架构的实现上具有灵活性6) 向下兼容AHB，APB接口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>AXI协议的关键特征：</li></ol><pre class="line-numbers language-none"><code class="language-none">1) 地址控制和数据相分离；2) 支持使用字节STROBE进行非对齐数据传输3) 突发事务只需要提供地址4) 读、写数据通道分离，实现更低成本的直接访问内存（DMA）5) 支持多Outstanding 地址6) 支持乱序传输实现7) 流水线<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6><span id="b-接口信号">b. 接口信号</span></h6><p><img src="https://img-blog.csdnimg.cn/2020120813320525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4><span id="2-axi通道">2. AXI通道</span></h4><p><img src="https://img-blog.csdnimg.cn/202012081326328.png" alt="在这里插入图片描述"></p><ol><li>读、写地址通道</li></ol><pre class="line-numbers language-none"><code class="language-none">i) 读写事务都有自己单独的读、写地址通道，地址通道携带传输所需的所有的地址和控制信息ii) AXI协议支持：One. 不同长度LEN的突发，1-16传输&#x2F;一个burstTwo. 突发传输SIZE 8- 1024 bitThree. 回环WRAP，增量INCR，非增量NON-INCRFour. 原子操作，使用独占、锁定访问Five. 系统级cache,和buffer控制Six. 安全和私有访问<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>读数据通道</li></ol><pre class="line-numbers language-none"><code class="language-none">读数据通道将读数据和读反应信息将从设备发送给主设备i) 数据bus，位宽8-1024 bitii) 读响应，表明读传输事务完成的状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>写数据通道</li></ol><pre class="line-numbers language-none"><code class="language-none">写数据通道，将写数据从主机发送到从机:i) 数据bus，位宽8-1024 bitii) 一个字节通道strobe，表明数据bus上哪一个字节是有效的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>写响应通道</li></ol><pre class="line-numbers language-none"><code class="language-none">写响应通道提供了写传输事务中，从机回应的信息每次burst完成后会提供完成信号，并不是一次burst传输中，每次传输都会给出，而只在最后完成时给出；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SOC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AMBA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMBA总线协议（三）——一文看懂AHB总线所有协议总结（AHB2 &amp; AHB-Lite &amp; AHB5 ）</title>
      <link href="/posts/91724fff66645676547745745.html"/>
      <url>/posts/91724fff66645676547745745.html</url>
      
        <content type="html"><![CDATA[<p>AMBA AHB 总线协议介绍请点击以下链接：</p><ol><li><a href="https://blog.csdn.net/vivid117/article/details/107511746">AMBA总线协议（一）——一文看懂APB总线协议</a></li><li><a href="https://blog.csdn.net/vivid117/article/details/110235612">AMBA总线协议（二）一文看懂AMBA2 AHB2与AMBA3 AHB-Lite总线协议的区别</a></li><li><a href="https://blog.csdn.net/vivid117/article/details/110501631">AMBA总线协议（三）——一文看懂AHB总线所有协议总结（AHB2 &amp; AHB-Lite &amp; AHB5 ）</a></li><li><a href="https://blog.csdn.net/vivid117/article/details/110673909">AMBA总线协议（四）——Multi-Layer AHB System (多层AHB总线架构)</a></li></ol><h3><span id="1-ahb-5-协议">1. AHB 5 协议：</span></h3><ol><li>AMBA AHB协议总线的接口适用于高性能的设计。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">主模块：Cortex-M内核，DMA存储器，DMA外设，以太网DMA USB等连接组件和从模块：内部Flash，内部SRAM，AHB2APB桥，APB外设之间的接口。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>大多数挂在总线上的模块，包括CPU只是单一属性的功能模块：主模块或者从模块。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">主模块是向从模块发出，读写操作的模块，如CPU, DSP等；从模块是接收命令并做出反应的模块，如片上RAM, AHB&#x2F;APB桥等；还有一些模块具有两种属性，例如DMA，在被编程时是从模块，在系统读传输数据时，是主模块；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>AHB 5总线特点：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a. 扩展存储类型b. 安全传输c. 字节顺序Endiand. 时钟稳定e. 独占传输（Exclusive transfer）f. 原子性访问 Multi-copy Atomicity额外：g. 锁定传输h. 多从机选择i. 原子性访问 Single-copy Atomicity j. 用户信号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="2-存储器类型extended-momory-type">2.     存储器类型（Extended Momory Type）</span></h3><p>AHB5 定义了扩展存储器类型的功能。定义接口是否支持扩展的存储器类型，如果没有定义，那么接口就不支持该类型<br><img src="https://img-blog.csdnimg.cn/20201202222118247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3><span id="3字节顺序endianness">3.字节顺序ENDIANNESS</span></h3><ol><li>AHB支持大端和小端系统，支持两种存储大端数据的方案；</li><li>AHB5 引入了Endian功能，定义支持哪种大端数据的方法：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">BE8：字节不变的大端模式; 字节访问（8bit）使用的数据总线 与小端模式访问地址相同；BE32：字不变的大端模式；字访问对最高有效字节与最低有效字节使用相同的数据总线位，与小端模式访问地址相同；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li><p>以下给出了那些可以使用小端模式，字节不变的大端模式，字不变的大端模式：</p><pre><code>    变量：</code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1) Address : 传输地址2) Data_bus_bytes：8 bit数据总线字节通道的数量；3) INT(x)：对X取整<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5><span id="a-小端模式">a. 小端模式：</span></h5><p>1) 当小端模式访问一个字节，下面方程显示使用了那些数据位</p><pre><code>Byte_Lane = Address - INT(Address / Data_bus_bytes) * Data_bus_bytes</code></pre><p>2) 数据在DATA[8<em>Byte_lane + 7 : 8</em>Byte_lane]上传输；</p><p>3) 当大的小端模式传输出现时，数据传输：</p><pre><code>1) 最低有效字节被驱动到传输地址上；2) 然后越来越大的字节按照地址递增的方式依次传输；</code></pre><h5><span id="b-字节不变的大端模式">b. 字节不变的大端模式：</span></h5><p>1) 当字节不变的大端模式访问一个字节，下面方程显示具体使用的数据位情况：</p><pre><code>Byte_Lane = Address –(INT(Address / Data_bus_Bytes)) × Data_Bus_Bytes</code></pre><p>2) 数据在DATA[8<em>Byte_lane + 7 : 8</em>Byte_lane]上传输；</p><p>3) 注意：</p><pre><code>1) 这和小端模式情况相同，因为大端和小端模式访问在字节传输上是等效的；</code></pre><p>4) 当大量的字节不变大端模式传输时，数据传输：</p><pre><code>1) 最高有效字节被驱动到传输地址上；2) 越来越少的字节数按照地址递增的方式依次传输</code></pre><h5><span id="c-字不变的大端模式">c. 字不变的大端模式：</span></h5><p>1) 当字不变的大端模式访问一个字节，下面方程显示具体使用数据位的情况：</p><pre><code>Address_Offset = Address –(INT(Address / Data_Bus_Bytes)) × Data_bus_BytesWord_Offset = (INT(Address_Offset / 4)) × 4Byte_Offset = Address_Offset – Word_Offset</code></pre><p>2) 数据在DATA[8<em>（Word_Offset + 3- Byte_Offset) + 7   :   8</em>(Word_Offset + 3 - Byte_Offset)上传输<br>3) 对于32 bit的数据总线，Word_Offset = 0， 并且公式可以简化为：DATA[8<em>（3- Byte_Offset) + 7   :   8</em>(3 - Byte_Offset)；</p></li></ol><p>有关AHB5， AHB-Lite， AHB2的其他详细介绍可以阅读官方SPEC文档，具体后续会有详细的介绍。</p><p>本次主要介绍AHB 三个版本的协议的相同点与不同点：</p><h3><span id="2-ahb-5-ahb-lite与ahb-2三个版本的介绍">2. AHB 5， AHB-Lite，与AHB 2三个版本的介绍</span></h3><p><img src="https://img-blog.csdnimg.cn/20201202220021442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>欢迎关注下面公众号，每周精选一篇原创文章！！！<br><img src="https://img-blog.csdnimg.cn/2020120222280630.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> SOC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AMBA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMBA总线协议（四）—— Multi-Layer AHB System (多层AHB总线架构)</title>
      <link href="/posts/917253435abaaa.html"/>
      <url>/posts/917253435abaaa.html</url>
      
        <content type="html"><![CDATA[<p>AMBA总线协议（四）——Multi Layer AHB System (多层AHB总线架构)</p><p>AMBA AHB 总线协议介绍请点击以下链接：</p><ol><li><a href="https://blog.csdn.net/vivid117/article/details/107511746">AMBA总线协议（一）—— 一文看懂APB总线协议</a></li><li><a href="https://blog.csdn.net/vivid117/article/details/110235612">AMBA总线协议（二）—— 一文看懂AMBA2 AHB2与AMBA3 AHB-Lite总线协议的区别</a></li><li><a href="https://blog.csdn.net/vivid117/article/details/110501631">AMBA总线协议（三）—— 一文看懂AHB总线所有协议总结（AHB2 &amp; AHB-Lite &amp; AHB5 ）</a></li></ol><h4><span id="1-介绍">1. 介绍：</span></h4><p>multi-layer AHB 是基于AHB互联架构：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">可以开发更多可用总线带宽的多主机系统可以构建灵活体系架构的复杂多主机系统；消除了在硬件设计阶段，就修改有关将系统资源分配给特定主机的设计决策要求可以使用标准的AHB主从模块而不需要修改每个AHB layer可以非常简单，因为只有一个主机，所以不需要仲裁，只需要MUX；可以使用AHB-Lite协议，即不需要请求和授予，不需要RETRY&#x2F;SPLIT事务；仲裁器可以高效的为每一个外设进行点仲裁，并且仅当多个主机希望同时访问同一从机时，才有必要；AHB 基础架构是多路选择器块，完成多主机到外设的连接由于多层架构是基于AHB协议，可以复用之前设计的主机和从机，而不需要修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20201204220435812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4><span id="2-应用">2. 应用：</span></h4><h6><span id="a-多层互连拓朴结构">a. 多层互连拓朴结构</span></h6><p>每一个主机都有自己的AHB layer，通过 interconnnect matrix 连接；<br><img src="https://img-blog.csdnimg.cn/20201204221712568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">说明：i. 每个layer有一个译码器，决定那个slave需要传输；ii. MUX决定了传输从适当的传输到所需要的slave;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4><span id="3-advance-options">3. Advance Options</span></h4><h6><span id="a-第一种私有从机">a. 第一种：私有从机</span></h6><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">i. 让slave私有，如slave4&#x2F;5只属于Master2，这将可以使用AHB-Lite来互连，减少了互连矩阵的复杂性；ii. 当从机只被一个主机使用时，可以使用此互连结构；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> <img src="https://img-blog.csdnimg.cn/20201204221755482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6><span id="b-第二种一个从端口上多从机">b. 第二种：一个从端口上多从机</span></h6><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">i. 让多个从设备单个挂载在互连矩阵上，这对于组合多个低带宽的从机很有用；ii. 可以用在一系列从设备被一个主设备访问（如DMA），而互联矩阵仅用在特殊情况下可以访问，如dubug系统时。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20201204221911268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6><span id="c-第三种一个layer层中多主机">c. 第三种：一个layer层中多主机</span></h6><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">i. 多主机共享一个Layer，适用于结合众多低带宽的多主机，如测试接口控制器TIC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20201204221918697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6><span id="d-第四种分离的ahb子系统">d. 第四种：分离的AHB子系统</span></h6><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">i. 每个layer可以成为完整的AHB子系统；ii. 单从设备。通常片上存储器，用作两个子系统的缓存区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20201204221927344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6><span id="e-第五种多端口的从设备">e. 第五种：多端口的从设备</span></h6><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">i. 多层AHB系统中，如SRAM控制器，可以并行被不同layer高效传输；ii. 通过设计从机有多个AHB从设备端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20201204221933586.png" alt="在这里插入图片描述"></p><h4><span id="4-例子">4. 例子：</span></h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a. CPU1有处于AHB layer 1;b. CPU2与DMA engine 共享AHB layer2;c. SRAM 仅连接至layer，仅可以被CPU1访问；d. LCD控制器，仅连至layer2,可以被DMA和CPU2访问；e. 互连矩阵，有两个从设备端口，两个都可以被两个layer层访问一个可以是AHB2APB桥，如下方多从机，能够挂载多低带宽的外设f. 外部SRAM接口有两个layer层的接口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20201204221940202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>欢迎关注下面公众号，每周精选一篇原创文章！！！<br><img src="https://img-blog.csdnimg.cn/20201204224429669.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> SOC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AMBA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMBA总线协议（二）——一文看懂AMBA2 AHB2与AMBA3 AHB-Lite总线协议的区别</title>
      <link href="/posts/91724fff6664567.html"/>
      <url>/posts/91724fff6664567.html</url>
      
        <content type="html"><![CDATA[<p>AMBA总线协议（二）一文看懂<strong>AMBA2 AHB2</strong>与<strong>AMBA3 AHB-Lite</strong>总线协议的区别 </p><ol><li><a href="https://blog.csdn.net/vivid117/article/details/107511746">AMBA总线协议（一）—— 一文看懂APB总线协议</a></li><li><a href="https://blog.csdn.net/vivid117/article/details/110235612">AMBA总线协议（二）—— 一文看懂AMBA2 AHB2与AMBA3 AHB-Lite总线协议的区别</a></li><li><a href="https://blog.csdn.net/vivid117/article/details/110501631">AMBA总线协议（三）—— 一文看懂AHB总线所有协议总结（AHB2 &amp; AHB-Lite &amp; AHB5 ）</a></li><li><a href="https://blog.csdn.net/vivid117/article/details/110673909">AMBA总线协议（四）——Multi-Layer AHB System (多层AHB总线架构)</a></li></ol><h2><span id="一-ahb-lite协议">一、AHB-Lite协议</span></h2><h4><span id="1-ahb-lite协议">1.     AHB-Lite协议：</span></h4><ol><li><p>AHB-Lite协议为AMBA 3 家族的AHB协议，其简化了AHB的协议复杂性；面向高性能，高频率系统设计；AHB-Lite Slave一般是内存器件（MCU）,外部存储器接口和高带宽外围器件，低带宽的器件也可以连接至AHB-Lite上，但是一般通过桥接器连接至APB总线上。</p></li><li><p>AHB-Lite协议为单Master,多Slave的，因此没有仲裁器。与AHB 2协议特性不同的是，没有分块传输，单周期总线移交操作。</p></li></ol><h4><span id="2-ahb-lite总线接口及结构">2. AHB-Lite总线接口及结构：</span></h4><p><img src="https://img-blog.csdnimg.cn/2020112716253249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>说明：上图中包含了AHB-Lite总线的各个模块的组成部分：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a. 主机b. 从机c. 译码器d. 多路MUX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="二-ahb-2-协议">二、AHB 2 协议</span></h2><p>下面是AHB 2协议简单介绍，具体功能介绍请参考官方SPEC文档</p><h4><span id="1-ahb总线协议">1. AHB总线协议</span></h4><h5><span id="a-主要用途用于高性能-高时钟频率的系统结构一般用于mcu">a. 主要用途：用于高性能、高时钟频率的系统结构，一般用于MCU;</span></h5><h5><span id="b-ahb总线的结构">b. AHB总线的结构：</span></h5><p><img src="https://img-blog.csdnimg.cn/20201127163224704.png" alt="在这里插入图片描述"></p><p>AHB总线将微控制器，RAM,外部存储器接口，DMA等各种具有AHB总线接口的控制器连接起来，构成独立的完整的SoC系统，不仅如此，也可以通过AHB2APB桥接器，连接至APB总线系统</p><h4><span id="2-ahb的基本特性">2. AHB的基本特性</span></h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Burst传输（突发传输）；Split事务处理（分块处理）；单周期总线Master移交；无三态；更宽的数据总线配置（如64，128等，具体规格可以根据自己来定）；流水线操作；可以支持多个主设备（最多16个）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4><span id="3-ahb总线的组成部分">3.  AHB总线的组成部分</span></h4><p><img src="https://img-blog.csdnimg.cn/20201127163242200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>说明：AHB总线由Master，Slave，和Infrastructure构成，infrastructure由arbiter，数据选择器，地址控制器，译码器构成；</p><h5><span id="主设备master">主设备Master</span></h5><pre><code>        1) 发起一次读、写操作；        2) 某一时刻只允许一个主设备使用总线；</code></pre><h5><span id="从设备slave">从设备Slave</span></h5><pre><code>        1) 响应一次读、写操作；        2) 通过地址映射来选择哪一个从设备（由译码器完成）</code></pre><h5><span id="仲裁器arbiter">仲裁器Arbiter</span></h5><pre><code>        1) 仲裁某一个主设备控制总线</code></pre><h5><span id="译码器decoder">译码器Decoder</span></h5><pre><code>        1) 通过地址译码决定选择哪一个从设备</code></pre><h4><span id="3-总线可以分为三路通道">3. 总线可以分为三路通道</span></h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">写数据总线读数据总线地址控制总线<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2><span id="三-ahb-2-与ahb-lite总线协议对比">三、 AHB 2 与AHB-Lite总线协议对比</span></h2><p>下表详细介绍了AHB-Lite协议与AHB2 协议的接口信息对比情况，以及各自的特点等<br><img src="https://img-blog.csdnimg.cn/20201127163426766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>欢迎关注下面公众号，每周精选一篇原创文章！！！<br><img src="https://img-blog.csdnimg.cn/20201127163558580.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> SOC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AMBA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMBA总线协议（一）——一文看懂APB总线协议</title>
      <link href="/posts/91724fff4567.html"/>
      <url>/posts/91724fff4567.html</url>
      
        <content type="html"><![CDATA[<h2><span id="0amba总线概括">0.AMBA总线概括</span></h2><p>AMBA AHB 总线协议介绍请点击以下链接：</p><ol><li><a href="https://blog.csdn.net/vivid117/article/details/110235612">AMBA总线协议（二）一文看懂AMBA2 AHB2与AMBA3 AHB-Lite总线协议的区别</a></li><li><a href="https://blog.csdn.net/vivid117/article/details/110501631">AMBA总线协议（三）——一文看懂AHB总线所有协议总结（AHB2 &amp; AHB-Lite &amp; AHB5 ）</a></li><li><a href="https://blog.csdn.net/vivid117/article/details/110673909">AMBA总线协议（四）——Multi-Layer AHB System (多层AHB总线架构)</a></li></ol><p><strong>AMBA（Advanced Microcontroller Bus Architecture）</strong> 总线是由ARM公司提出的一种开放性的片上总线标准，它独立于处理器和工艺技术，具有高速度低功耗等特点。</p><p>系统芯片中各个模块之间需要有接口来连接；<br>总线作为子系统之间共享的通信链路；</p><p>其优点：<strong>低成本，方便易用</strong><br>缺点：<strong>容易有性能瓶颈</strong><br>AMBA总线的发展历史：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">AMBA 1.0 : ASB, APBAMBA 2.0 : AHB, ASB, APBAMBA 3.0 : AMBA Advanced eXiensibele Interface (AXI)AMBA 4.0 : ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>AMBA总线体系包括以下三种总线：</p><ol><li>AHB：Advanced High-performance Bus，用于高性能、高时钟工作频率模块。</li><li>ASB：Advanced System Bus，用于高性能系统模块。</li><li>APB：Advanced Peripheral Bus，用于慢速外设模块。</li></ol><p>下面给出一个典型的AMBA系统：<br><img src="https://img-blog.csdnimg.cn/20200722135145430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以一个SOC系统架构设计为例：<br><img src="https://img-blog.csdnimg.cn/20200722135414158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从AHB/ASB总线到APB总线需要通过 <strong>桥接器（Bridge）</strong> 进行互联。</p><h2><span id="1apb总线介绍">1.APB总线介绍</span></h2><p>应用于慢速外设，如UART、键盘等，不需要AHB总线体系中的Arbiter与Decoder。<br>Arbiter为仲裁器，决定哪个Master工作。Decoder为译码器，决定Master与哪个Slave进行数据传输。</p><p><strong>1.1 接口主要信号</strong><img src="https://img-blog.csdnimg.cn/20200722135723312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="主要"><br>可以看出，APB总线接口主要有 <strong>系统信号，地址信号，方向信号，数据信号，传输阶段控制信号</strong></p><h2><span id="2apb总线传输介绍时序部分">2.APB总线传输介绍（时序部分）</span></h2><h3><span id="21-状态机">2.1 状态机</span></h3><p><img src="https://img-blog.csdnimg.cn/20200722140053466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从状态机看,APB对每一笔数据的传送，均需<strong>花 2 个周期的时间</strong>，且 APB 的数据传递<strong>不适用在有流水线架构的模块设计</strong>中<br><img src="https://img-blog.csdnimg.cn/20200722140222293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3><span id="22-写操作"><strong>2.2 写操作</strong></span></h3><p>下图表示APB基本的写操作<br><img src="https://img-blog.csdnimg.cn/20200722140404401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>在 T1 时，有限状态机进入预设的 <strong>IDLE 状态</strong>；</li><li>在 T2 时，数据地址、读写控制信号和写入的数据会在频率正沿触发时，开始作写的数据传递准备，这个周期也就是刚才所提及<strong>SETUP状态</strong>。==译码电路在此状态会根据数据地址去译码出所要写入APB Slave，此时所对应到 S 的 PSEL 信号将由 0 变 1；==</li><li>在 T3 时，有限状态机会进入 <strong>ENABLE 状态</strong>，PENABLE 信号在此状态会被设成 1；</li><li>在 T4 频率正沿触发时，PENABLE 信号将由 1 变 0，而 PSEL 信号在若没有其它数据的写入动作时，也将由 1 变 0。为了减少功率的消耗，APB 的数据地址和读写控制信号在下一笔数据传递前，将不会作任何改变。<h3><span id="23-读操作">2.3 读操作<img src="https://img-blog.csdnimg.cn/20200722140636671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></span></h3>由图中可发现除了写信号是倒过来有效外，APB 读操作时序图和写操作时序图非常相似，在这里我们就不再作详细的解释。<br>要特别注意的是，在 T3 后，也就是在进入 ENABLE 周期后，==APB 从必须要将 M 所要读取的数据准备好==，以便 M 可以在 ENABLE 周期末被 T4 正时钟沿触发时正确的将数据读取。</li></ol><h2><span id="3apb到ahb的接口">3.APB到AHB的接口</span></h2><h3><span id="31读操作">3.1读操作</span></h3><p><img src="https://img-blog.csdnimg.cn/20200722140937147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在频率很高的情况下，<strong>在ENABLE CYCLE中可能数据不能够直接映射到AHB总线，需要在APB桥中在T4的时候打一下锁住，并在T5的时候才被AHB主采样。虽然需要多一个等待周期（一共2个，HREADY反压两拍），但是由于频率提升了因此总的性能也提升了。</strong><br>  T1：在 AHB 总线开始传送；<br>  T2：地址被 APB 总线采样。如果该传送是针对外设的话，这个地址就会被译码成选择信号发往外设。T2就是 AHB 的SETUP CYCLE。<br>  T3：APB 的 ENALBE CYCLE，PENABLE 拉高，数据被读出。<br>  T4：读出的数据直接映射到 AHB 总线上，在上升沿被 AHB 主采样。  </p><h3><span id="32-写操作">3.2 写操作</span></h3><p><img src="https://img-blog.csdnimg.cn/20200722141132986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>APB总线上的单块数据写操作不需要等待周期。APB桥的责任是对地址和数据进行采样，并在写操作的过程中保持它们的值。<br>  T1：AHB 开始作数据地址和读写控制信号的传递(HADDR 和 HWRITE)<br>  T2：APB bridge 栓取住 AHB 送来的数据地址及读写控制信号，同时进入到 APB 有限状态机的 ENABLE状态<br>  T3~：其后的读和写动作跟之前所介绍的 APB 读写动作一模一样，在这里我们不再加以详述。<br>下图是突发写传输时序图：<br><img src="https://img-blog.csdnimg.cn/20200722141302282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>虽然第一个传输可以零状态等待状态玩抽，但之后到外设总线的传输将为每个传输的执行要求一个等待状态。<br> APB桥中需要有 2 个地址寄存器，当处理一个数据块写操作时，可以寄存下一个数据块的地址。</p><h3><span id="33-背靠背操作">3.3 背靠背操作</span></h3><p>下图给出了背靠背传输的时序，分别写，读，写，读</p><p><img src="https://img-blog.csdnimg.cn/20200722141646258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果写操作之后跟随着读操作，那么需要 3 个等待周期来完成读操作。通常的情况下，不会有读操作之后紧跟着写操作的发生，因为两者之间 CPU 会进行指令读取。</p>]]></content>
      
      
      <categories>
          
          <category> SOC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AMBA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AHB2APB桥接器设计（1）——基本原理</title>
      <link href="/posts/1234a.html"/>
      <url>/posts/1234a.html</url>
      
        <content type="html"><![CDATA[<p>🔥点击进入<a href="https://bbs.csdn.net/forums/hardware_security">【硬件安全】</a>社区，查看更多精彩内容🔥</p><p><a href="#box">🔥点击查看《AMBA总线》系列文章🔥</a>   </p><blockquote><p>📢 <strong>声明</strong>：<br>🥭 作者主页：<a href="http://weivid.vip">【摆渡沧桑的CSDN主页】</a>。<br>⚠️ 未经作者允许，禁止转载。<br>⚠️ 本文为非盈利性质，目的为个人学习记录及知识分享。因能力受限，存在知识点分析不正确的可能。若您参考本文造成了不良后果，本人不承担相关责任。<br>⚠️ 若本文所采用图片或相关引用侵犯了您的合法权益，请联系我进行删除。<br>😄 欢迎大家指出文章错误，欢迎同行与我交流 ~</p></blockquote><p>@[toc]</p><h2><span id="一-ahb2apb桥的基本原理">一、AHB2APB桥的基本原理</span></h2><h3><span id="1-ahb与apb总线">1. AHB与APB总线</span></h3><blockquote><p>AHB: Advanced High-performance Bus，高级高性能总线<br>APB: Advanced Peripheral Bus，高级外设总线</p></blockquote><h3><span id="2-ahb与apb总线的特性">2. AHB与APB总线的特性</span></h3><p><strong>AHB:</strong></p><blockquote><p>1.高性能、高时钟频率、高带宽<br>2.多master并行操作、Burst突发操作、split分片传输、2级流水线传输<br>3.可以作为master接口，也可以作为slave接口<br>4.CPU、DSP、DMA、FLASH、SRAM等</p></blockquote><p><strong>APB：</strong></p><blockquote><p>1.低速、低带宽<br>2.设计简单，只有SETUP、ENABLE两个状态<br>3.专为降低功耗和接口复杂而设计的总线<br>4.只作为slave属性的外设总线<br>5.常见的有UART,I2C,SPI,RTC,GRCC,PWM等</p></blockquote><h3><span id="3-ahb2apb桥的作用为什么会有桥">3. AHB2APB桥的作用（为什么会有桥？）</span></h3><blockquote><pre><code>1.用于AHB主设备到APB的从设备的连接2.完成AHB和APB协议的转换、以及异步数据的通信3.AHB2APB桥是AHB总线上的从设备，也是APB总线唯一一个主设备</code></pre></blockquote><h3><span id="4-soc系统中的ahb2apb桥所处的位置">4. SoC系统中的AHB2APB桥所处的位置</span></h3><p><img src="https://img-blog.csdnimg.cn/d5edabefd64948609d7601e2dadd454d.png" alt="在这里插入图片描述"></p><blockquote><p>左边是SoC系统中基本的master，如Cortex M3， 通过matrix仲裁器会将总线地址，分别映射到AHB的slave中，<br>中间通过两个bridge（外设众多，可以通过两组bridge来管理不同外设），AHB将与APB上的从设备通信</p></blockquote><h2><span id="二-ahb2apb桥的分类按照时钟频率来分">二、AHB2APB桥的分类（按照时钟频率来分）</span></h2><h3><span id="1-soc系统总线的时钟分布">1. SoC系统总线的时钟分布</span></h3><blockquote><ol><li>SOC系统中时钟来源很多，如对于RTC，WatchDog等外设，对于时钟频率的要求很低（32.768KHz）但是对于CPU，DMA，Memory等可能需要很高的时钟频率，这样会用到PLL产生高频率的时钟</li><li>对于AHB总线的时钟，会对main clk进行分频，得到APB的时钟，可以设置不同的时钟工作频点，分别得到AHB和APB总线的时钟频率</li><li>对于AHB和APB总线，他们各自上的时钟频率可能是不一样的，也可能是相同的，同步桥和异步桥</li></ol></blockquote><h3><span id="2-ahb2apb桥的分类">2. AHB2APB桥的分类</span></h3><blockquote><pre><code>1. 复杂的SoC系统，由于时钟的多样性，导致AMBA总线的规范并没有规定AHB，APB总线的时钟关系2. 但是在一般的SoC中，为了灵活配置AHB，APB的时钟频率，所以AHB，APB工作时钟频率不一样3. AHB2APB同步桥：AHB和APB时钟来源相同，相位相同4. AHB2APB异步桥：AHB和APB时钟频率、相位可以相同也可以不同</code></pre><p><img src="https://img-blog.csdnimg.cn/ca4666e3ba794964be4925ef2e9bf1d7.png" alt="在这里插入图片描述"></p></blockquote><h2><span id="三-ahb2apb同步桥-时钟来源-相位相同apb使用的时钟和ahb的时钟相同">三、AHB2APB同步桥 （时钟来源、相位相同）——APB使用的时钟和AHB的时钟相同</span></h2><h3><span id="1-同步桥的优点">1. 同步桥的优点：</span></h3><blockquote><pre><code>1. 设计简单、综合出来的面积小2. 非流水线结构、稳定可靠</code></pre><ol><li>整个总线系统由单个时钟控制，有利于时序分析和综合</li></ol></blockquote><h3><span id="2-同步桥缺点">2. 同步桥缺点：</span></h3><blockquote><pre><code>1. 从设备功耗高2. 从设备工作时钟频率高，对设计时序有较高要求</code></pre></blockquote><h2><span id="四-ahb2apb异步桥时钟频率-相位可以相同也可以不同">四、AHB2APB异步桥（时钟频率、相位可以相同也可以不同）</span></h2><h3><span id="1-异步桥的优点">1. 异步桥的优点：</span></h3><blockquote><pre><code>1. APB时钟可以灵活配置2. 有利于功耗控制</code></pre></blockquote><h3><span id="2-异步桥的缺点">2. 异步桥的缺点：</span></h3><blockquote><pre><code>1. 设计复杂、需要增加跨时钟域的同步处理2. AHB读写低频APB设备需要调节等待周期，降低AHB主设备的性能3. APB的时钟频率会限制外设的最高传输速度，如SPI, UART等</code></pre></blockquote><p><div id="box"></div></p><p id="box"></p><p>🔥 <strong><em>精选往期 《AMBA总线》系列文章</em></strong>🔥</p><p><strong><em>【协议篇】</em></strong><br><a href="https://blog.csdn.net/vivid117/article/details/107511746"><strong><em>AMBA总线协议（一）——一文看懂APB总线协议</em></strong></a><br><a href="https://blog.csdn.net/vivid117/article/details/110235612"><strong><em>AMBA总线协议（二）——一文看懂AMBA2 AHB2与AMBA3 AHB-Lite总线协议的区别</em></strong></a><br><a href="https://blog.csdn.net/vivid117/article/details/110501631"><strong><em>AMBA总线协议（三）——一文看懂AHB总线所有协议总结（AHB2 &amp; AHB-Lite &amp; AHB5 ）</em></strong></a><br><a href="https://blog.csdn.net/vivid117/article/details/110501631"><strong><em>AMBA总线协议（四）—— Multi-Layer AHB System (多层AHB总线架构)</em></strong></a><br><a href="https://blog.csdn.net/vivid117/article/details/110871257"><strong><em>AMBA总线协议（五）—— AXI3 协议接口信号介绍1</em></strong></a><br><a href="https://blog.csdn.net/vivid117/article/details/110871426"><strong><em>AMBA总线协议（六）—— 一文看懂 AXI3 协议原子访问2</em></strong></a><br><a href></a><br><a href></a><br><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> SOC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AMBA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学之公钥密码体系（4）：Rabin公钥密码方案</title>
      <link href="/posts/e9989081226666663agfda.html"/>
      <url>/posts/e9989081226666663agfda.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>📢 <strong>声明</strong>：<br>🥭 作者主页：<a href="http://www.weivid.vip">【Janice主页】</a>。<br>⚠️ 未经作者允许，禁止转载。<br>⚠️ 本文为非盈利性质，目的为个人学习记录及知识分享。因能力受限，存在知识点分析不正确的可能。若您参考本文造成了不良后果，本人不承担相关责任。<br>⚠️ 若本文所采用图片或相关引用侵犯了您的合法权益，请联系我进行删除。<br>😄 欢迎大家指出文章错误，欢迎同行与我交流 ~</p></blockquote><h2><span id="一-rabin公钥密码方案">一、Rabin公钥密码方案</span></h2><p>Rabin密码体制，被认为是对RSA密码体制的改进，其安全性基于求合数的模平方根的难度。而这个困难性等价于求解因子分解。RSA算法中只要素数被分解，密码就会被破解。而Rabin方案其实可以看做为RSA方案的一个特例，但被证明破译的难度和分解大整数一样难度。<br>Rabin方案的特点：</p><ol><li>Rabin 方案不是一一映射的，对于同一个密文，可能会有多个对应的明文；</li><li>Rabin算法的安全性基于求解合数模平方根困难性问题，破解难度和大整数分解相当；</li><li>Rabin算法可以看做为RSA算法的一个特例，即指数取2</li></ol><h2><span id="二-rabin公钥密码加-解密方案">二、Rabin公钥密码加、解密方案</span></h2><h3><span id="1-密钥生成">1. 密钥生成</span></h3><p>首先，随机选择两个大素数 $p,q$，并满足如下条件：</p><script type="math/tex; mode=display">p≡q≡3 mod 4</script><p>即$q,p$可以表示为$4k+3$的数学形式，在将得到的素数相乘:</p><script type="math/tex; mode=display">n=q*p</script><p>其中，$n$即为公钥，$q,p$即为私钥。<br>想要破解通过公钥n破解对应的私钥，这是十分困难的。</p><h3><span id="2-加密方案">2. 加密方案</span></h3><p>加密过程为：</p><script type="math/tex; mode=display">c≡m^2 \mod n</script><p>加密的过程很简单，与RSA相比，只是将指数改为常数$2$。当攻击者不知道私钥的情况下，拿到密文$c$时，想要恢复明文$m$,相当于需要求解密文$c$在模$n$时的平方根，这与大整数分解的难度是等价的。</p><h3><span id="3-解密方案">3. 解密方案</span></h3><p>解密时，求解密文$c$在模$n$下的平方根。即求解：</p><script type="math/tex; mode=display">x^2≡c \mod n</script><p>由于n可以分解为$p$和$q$，因此，根据中国剩余定理，可以将上面方程等价于如下方程组：</p><script type="math/tex; mode=display">\begin{cases}x^2≡c \mod p,\\x^2≡c \mod q,\end{cases}</script><p>由于$p≡q≡3 \mod 4$,因此，很容易求解方程组：</p><script type="math/tex; mode=display">x≡y \mod p, x≡-y \mod p \\x≡z \mod q, x≡-z \mod q</script><p>经过组合，可以得到如下四个方程组：</p><script type="math/tex; mode=display">\begin{cases}x≡y \mod p\\x≡z \mod q\end{cases} \\</script><script type="math/tex; mode=display">\begin{cases}x≡-y \mod p\\x≡z \mod q\end{cases}\\</script><script type="math/tex; mode=display">\begin{cases}x≡y \mod p\\x≡-z \mod q\end{cases}\\</script><script type="math/tex; mode=display">\begin{cases}x≡-y \mod p\\x≡-z \mod q\end{cases}\\</script><p>因此，有中国剩余定理可以解出每一个方程组的解，一共有$4$组解，因此可以看出，每一个密文所对应的明文均不唯一。<br>为了解决这个办法，可以在加密$m$时，在$m$的明文信息中加入私人信息，供解密使用。</p><h2><span id="三-rabin方案具体案例">三、Rabin方案具体案例</span></h2><ol><li>选择$p=7,q=11, n=77$,因此，明文空间为$P={0,1,2,…,76}$</li><li>选择加密明文为$m=20$， 加密之后密文$c=20^2 mod 77 =15$</li><li>当$n$很大，无法破解时，我们无法计算，如果我们假设以及知道了$77$的两个因子为$7$和$11$，已知密文为$15$，求解明文$m$.<script type="math/tex; mode=display">m=\sqrt{c} \mod p \\m=\sqrt{c} \mod q</script>由于$p≡q≡3 \mod 4$,因此，有如下公式成立：<script type="math/tex; mode=display">m=c^{1/4(p+1)} \mod p,m=-c^{1/4(p+1)} \mod p\\m=c^{1/4(q+1)} \mod q,m=-c^{1/4(q+1)} \mod q</script>两两一组，可以求解$m$为${64,20,13,57}$</li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cryptography Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学之公钥密码体系（3）：Elgamal算法</title>
      <link href="/posts/e9989081226666663.html"/>
      <url>/posts/e9989081226666663.html</url>
      
        <content type="html"><![CDATA[<p>公钥密码体系之Elgamal算法3</p><h3><span id="1-elgamal算法">1. ElGamal算法</span></h3><p>ElGamal算法是基于离散对数求解困难的加密体系。与RSA算法一样，都能用于数据加密和数据签名。但是两者的原理不一样，ELGmal算法基于离散对数问题，而RSA算法基于大数分级困难问题。此外，对于ElGamal算法对于使用相同的私钥，对相同的明文进行加密，每次得到的加密结果却不一样，这是ElGamal算法另一个重要特征。</p><h3><span id="2-elgamal算法基本原理">2. ElGamal算法基本原理</span></h3><h5><span id="21-elgamal密钥生成">2.1 ElGamal密钥生成</span></h5><ol><li>随机选择一个大素数$p$，且要求 $p-1$有大素数因子。再选择一个模$p$的本原元$g$。将$p$和$g$公开。</li><li>随机选择一个整数$x$作为<strong>私钥</strong>，$2≤x≤ p-2$ </li><li>计算<script type="math/tex">y=g^x mod  p</script><br>取$y$为<strong>公钥</strong>。</li></ol><h5><span id="22-elgamal加密过程">2.2 ElGamal加密过程</span></h5><ol><li>对明文$M$进行加密，随机地选取一个整数$k$，$2≤k≤p-2$,并要求$k$与$p-1$互素</li><li>计算：<script type="math/tex; mode=display">a＝g^k mod p$$   $$b＝M*y^k mod p</script></li><li>密文对为$（a,b）$，并且密文的大小时明文的两倍。</li></ol><h5><span id="23-elgamal解密过程">2.3 ElGamal解密过程</span></h5><ol><li>由密文可得明文$M$，计算<script type="math/tex; mode=display">M=b/a^x mod p</script>其中$x$为私钥。</li><li>解密过程和Diffie-Hellman密钥交换过程极为类似。</li><li>下面给出了加密和解密过程<br><img src="https://img-blog.csdnimg.cn/56aa51c3b6534b5ea1b725cf9e60ffef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pGG5rih5rKn5qGR,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ol><h5><span id="24-elgamal签名过程">2.4 ElGamal签名过程</span></h5><h5><span id="签名">签名：</span></h5><ol><li>对消息$M$进行签名时，首先选择一个随机数$k$,并要求$k$与$p-1$互素。</li><li>计算：<script type="math/tex; mode=display">a=g^kmodp</script></li><li>利用扩展欧几里得算法，求出b:<script type="math/tex; mode=display">M=(xa+kb)mod(p-1)</script></li><li>签名结果为（a,b）。需要注意的是，k需要保密。</li></ol><h6><span id="验签">验签：</span></h6><ol><li>需要验证下面公式成立：<script type="math/tex; mode=display">y^aa^bmodp=g^Mmodp</script></li><li>下面给出签名和验签的大致流程<br><img src="https://img-blog.csdnimg.cn/784bd0728d0b40dba0f014c5b834f714.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pGG5rih5rKn5qGR,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>需要注意的是，在每次使用ElGamal算法进行签名时，都需要更新随机数k。<h6><span id="具体案例">具体案例：</span></h6></li><li>选择$p=11,g=2$,私人秘钥$x=8$,计算：<script type="math/tex; mode=display">y=g^xmodp => y=2^8 mod 11 = 3</script></li><li>因此，公开秘钥是$y=3,g=2,p=11$</li><li>对消息$M=5$进行签名，首先随机选择随机数$k=9$，验证$gcd（9,10）=1$，计算：<script type="math/tex; mode=display">a=g^kmodp=2^9mod11=6</script>利用欧几里得算法求b:<script type="math/tex; mode=display">M=(ax+kbmod(p-1)) $$  $$ 5=(8*6 + 9*b)mod10</script>求解得到$b=3$,于是签名对$(a,b)$为$（6,3）$</li><li>验签上述签名的正确性，只需要验证下面：<script type="math/tex; mode=display">y^aa^bmodp=g^Mmodp$$ $$3^66^3mod11=2^5mod11</script></li></ol><h5><span id="25-elgamal算法软件算法实现的快慢">2.5 ElGamal算法软件算法实现的快慢</span></h5><p>具有160 bit的指数的ElGamal算法对不同模数长度的快慢表<br><img src="https://img-blog.csdnimg.cn/34a895e2e42e48c8ba8d2614073f9688.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cryptography Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学之公钥密码体系（2）：RSA算法2</title>
      <link href="/posts/e99890812263.html"/>
      <url>/posts/e99890812263.html</url>
      
        <content type="html"><![CDATA[<p>密码学——公钥密码体系之RSA算法2</p><h3><span id="一-rsa算法背景">一、RSA算法背景</span></h3><p>上一讲介绍了公钥密码体系中的背包算法，在Merkle背包算法出现后不久，便出现了第一个比较完善的公开秘钥算法RSA，它可以用于加密也可以用于数字签名（一般常用作数字签名，速度较快）。</p><p>RSA算法以它的三个发明者Ron Rivest，Adi Shamir和Leonard Adleman的名字命名。</p><p>RSA的安全基于大数分解的难度。其公开密钥和私人秘钥是一对大素数的函数。从一个公开密钥和密文中恢复出明文的难度等价于分解两个大素数之积。</p><h3><span id="二-rsa算法描述">二、RSA算法描述</span></h3><ol><li>为了产生两个密钥，选取两个大素数$p$和$q$.为了获得最大程度的安全性，两数的长度一样。计算乘积。<script type="math/tex; mode=display">n=pq</script></li><li>然后随机算去加密密钥$e$，使得 $e$ 和$(p-1)(q-1)$互素。最后用欧几里得扩展算法计算解密密钥$d$,以满足<script type="math/tex; mode=display">ed = 1 mod (p-1)(q-1)</script>则<script type="math/tex; mode=display">d=e^{-1}mod(p-1)(q-1)</script>其中，$d$与$n$也互素。$e$和$n$是公开密钥，两个素数$p$和$q$不再需要，他们应该被舍弃，但绝不能泄露</li></ol><p>加密消息$m$时，首先将它分成比n小的数据分组（采用二进制数，选取小于n的2的最大次幂）。也就是说，如果$p$和$q$为100位素数，那么n将有200位，每个消息分组mi应小于200位长（如果需要加密固定的消息分组，那么可以在它的左边填充0，并确保该数比n小）。加密后的密文c，将由相同长度的分组ci组成。加密公式简化为：</p><script type="math/tex; mode=display">c_i=m_i^emod(n)</script><p>解密消息时，取每一个加密后的分组ci并计算：<br><img src="https://img-blog.csdnimg.cn/20210529205337710.png" alt><br>这个公式能恢复明文，如下<br><img src="https://img-blog.csdnimg.cn/20210529205620487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt><br>消息用d加密就像用e解密一样容易。</p><p><strong>举一个简单的例子</strong>：<br>选择$p=47$，$q=71$，那么</p><script type="math/tex; mode=display">n=pq=3347</script><p>加密密钥$e$必须与$(p-1)(q-1)=46*70=3220$没有公因子。<br>随机选取$e=79$，那么：</p><script type="math/tex; mode=display">d=79^{-1}mod3220=1019</script><p>该结果使用扩展欧几里得算法求出。公开$e$和$n$，将$d$保密，丢弃$p$和$q$。</p><p>对于加密消息：$m=688232687966668003$<br>首先将其分为小的分组。在此例中，按3位数字一组就可以进行加密。这个消息将分成6个分组m，进行加密：<br>$m_1=688$<br>$m_2=232$<br>$m_3=687$<br>$m_4=966$<br>$m_5=668$<br>$m_6=003$</p><p>第一个分组加密为：<br>$688^{79}mod3337 = 1570 = c_1$<br>对随后的分组进行同样的运算产生加密后的密文：</p><script type="math/tex; mode=display">c=15702756209122762423158</script><p>解密消息时需要用解密密钥1019进行相同的指数运算。因而</p><script type="math/tex; mode=display">1570^{1019}mod3337=688=m_1</script><p>消息的其余部分可用同样的方法恢复出来</p><h3><span id="三-rsa的硬件实现">三、RSA的硬件实现</span></h3><ol><li>已有的RSA芯片<br><img src="https://img-blog.csdnimg.cn/20210530171636900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt></li><li><p>RSA速度<br>RSA硬件实现时，RSA比DES慢大约1000倍。最快的具有512位模数的VLSI硬件实现的吞吐量为64Kbit每秒。也有一些实现1024位RSA的加密芯片。如今设计512bit的芯片可以达到1Mb/s，该芯片在1995年制成。在智能卡中已经大量实现了RSA，这些实现都比较慢。</p><p> 有兴趣的读者可以关注我之前的专门RSA硬件设计专栏：<br><a href="https://blog.csdn.net/vivid117/article/details/114192073?spm=1001.2014.3001.5501">基于Montgomery算法的高速、可配置RSA密码IP核硬件设计系列博文</a></p><p> 软件实现时，DES大约比RSA快100倍。这些数字会随着技术发展而发生相应的变化，但RSA的速度将永远不会达到对称算法的速度。下表给出了软件实现RSA算法的情况：<br><img src="https://img-blog.csdnimg.cn/20210530172239956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt></p></li><li>RSA硬件和软件加速<br>对于RSA硬件实现，可以采用<strong>蒙哥马利算法</strong>来加速硬件。</li></ol><p>如果很适当的选择了一个$e$值，RSA加密速度将快很多。最常用的三个$e$值为3,17和65537（2^16+1）（二进制表示只有两个1，所以只需要17次乘法来实现指数运算）。<br><strong>X.509</strong>中建议采用65537；<br><strong>PEM</strong>中建议采用3；<br><strong>PKCS#1</strong>中建议采用3和65537；<br>即便是一组用户使用同样的$e$值，采用这三个值中的任何一个都不存在安全问题<br>假如已经保存了$p$和$g$值，以及诸如$dmod(p-1)、q^{-1}dmod(p-1)、modp$这类数，那么运用<strong>中国剩余定理</strong>就能使私人密钥的运行速度加快。这些数很容易从私人密钥和公开密钥中计算出来。</p><h3><span id="四-rsa的安全性">四、RSA的安全性</span></h3><p>对于RSA的安全性完全依赖于大数分解的难度，从技术上来说，这是不正确的，只是一种推测。<br>从数学上从未证明过，需要分解n才能从$e$和$c$中计算出$m$。用一种完全不同方法来对RSA进行密码分析还只是一种想象。如果这种新方法能让密码分析者推算出$d$,也可以作为分解大数的一种新方法。</p><p>也可以通过猜测$(p-1)(q-1)$的值来攻击RSA。但这种攻击没有分解n容易。</p><p>对于持有极端怀疑态度的人来说，有些RSA的变型已经被证明和大数分解同样困难。分解$n$是最显而易见的攻击方法。敌方手中有公开秘钥$e$和模数$n$，要找到解密密钥$d$，他们就必须分解$n$，目前，<strong>129位十进制数字的模数是能分解的临界数。所以，n应该大于这个数</strong>。</p><p>对于密码分析者来说，有可能尝试每一种可能的d，直到获得正确的一个。这种穷举攻击还没有试图分解$n$更有效。</p><p>随着时间的推移，声称已经找到破译RSA的简单方法，但直到现在这些宣称还没有强有力的证据。</p><p>还有其他的担心，大多数用于计算素数$p$和$q$的算法是有概率的，假如$p$和$q$不是素数又如何？首先可以找出这件事发生尽可能小的概率。如果不是素数，这就意味着加密和解密均不能正确的工作，可以立即放弃。出现这种问题的主要原因是素性检测是基于概率来检测的。</p><h3><span id="五-对rsa的选择密文攻击">五、对RSA的选择密文攻击</span></h3><p>有些攻击专门针对RSA的实现。他们不攻击算法本身，而是<strong>攻击协议</strong>。仅使用RSA而不重视它的实现时不够的。实现的细节其实也很重要</p><p><strong>情形1——攻击协议</strong>：Eve在Alice的通信过程中进行窃听，设法成功选取一个用她的公开秘钥加密的密文$c$，Eve想读出消息。从数学角度来说，她想得到$m$，这里：</p><script type="math/tex; mode=display">m=c^d$$为了恢复$m$，首先先选取一个随机数$r$，满足$r$小于$n$。他得到的Alice的公开秘钥$e$,然后计算：$$x=r^emodn$$$$y=xcmodn$$$$t=r^{-1} modn</script><p>如果$x=r^emodn$，那么$r=x^dmodn$<br>现在，Eve让Alice用她的私人秘钥对y签名，以便解密$y$（Alice必须对消息，而非消息的散列值签名）。记住，Alice以前从未见过$y$.Alice发送给Eve:</p><script type="math/tex; mode=display">u=y^dmodn</script><p>现在Eve计算：</p><script type="math/tex; mode=display">tumodn=r^{-1}y^dmodn=r^{-1}x^dc^dmodn=c^dmodn=m</script><p>那么Eve，现在就获得了m。</p>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cryptography Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件安全技术——芯片安全设计技术4（PUF）</title>
      <link href="/posts/675857645754.html"/>
      <url>/posts/675857645754.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是PUF"><a href="#一、什么是PUF" class="headerlink" title="一、什么是PUF"></a>一、什么是PUF</h3><h5 id="1-物理不可克隆函数——PUF"><a href="#1-物理不可克隆函数——PUF" class="headerlink" title="1. 物理不可克隆函数——PUF"></a>1. 物理不可克隆函数——PUF</h5><p>物理不可克隆函数(即PUF：physical unclonable function)是一种芯片的<strong>数字指纹</strong>，用作半导体设备(如微处理器)的唯一身份，增强了芯片抵抗逆向的能力。</p><p>PUF通常用于密码学。物理不可克隆函数是物理结构中体现的物理实体。目前，PUF通常用集成电路来实现，通常用于对安全性要求较高的应用中。</p><p>从2010年到2013年，PUF在<strong>智能卡市场</strong>获得了关注，作为提供“<strong>硅指纹</strong>”的有前途的方式，创建了独特于个人智能卡的加密密钥。<br><img src="https://img-blog.csdnimg.cn/20210529150929642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>现在，PUF成为商用FPGA中安全替代电池备份秘密密钥的存储器，如Xilinx Zynq Ultrascale ++ 和Altera。</p><p>PUF取决于其物理微结构的独特性。<strong>这种微观结构取决于制造过程中引入的随机物理因素</strong>。这些因素是<strong>不可预测和不可控制</strong>的，这使得<strong>复制或克隆结构</strong>几乎是不可能的。</p><p>但是这只是一项芯片设计模块功能，与<strong>TrustZone技术</strong>存在本质区别。</p><h5 id="2-PUF特性"><a href="#2-PUF特性" class="headerlink" title="2. PUF特性"></a>2. PUF特性</h5><p><img src="https://img-blog.csdnimg.cn/20210529151253585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>唯一性<br>每一个芯片都是随机分布的、唯一的<ol><li>防克隆性<br>芯片本身就是在芯片制造过程中由于不确定因素提取出来的，无法重新复制相同的PUF值</li><li>不可预测性<br>由于芯片在制造出来之前，没有办法来预测</li><li>防篡改性<br>芯片本身PUF值无法定位修改</li><li>无需存储<br>每次芯片启动只需要在电路结构中提取，无需存储器件来存储</li></ol></li></ol><h5 id="3-PUF结构"><a href="#3-PUF结构" class="headerlink" title="3. PUF结构"></a>3. PUF结构</h5><p><img src="https://img-blog.csdnimg.cn/20210529152437793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li><p>SRAM PUF<br>SRAM PUF利用SRAM Cell，首尾相接的反相器，在制造过程中，虽然电路架构完全一样，但是电路驱动能力有强弱之分，导致SRAM在上电时的Cell上0,1的分布是随机分布的，因此，利用这个特征可以提取出PUF</p></li><li><p>仲裁PUF<br>仲裁PUF，同一个信号从起点到终点所用的时间（延迟），在制造过程中会存在误差。</p></li><li><p>RO PUF（环形振荡器）<br>环形振荡器PUF，利用环形振荡器电路，在不同芯片制造出来之后，频率产生也会存在误差</p></li><li><p>VIA PUF<br>实际设计中，VIA存在设计规则，利用设计规则，设计从小到大的孔洞，根据工艺的特性，来提取出VIA PUF</p></li></ol><h5 id="5-与TrustZone技术的区别"><a href="#5-与TrustZone技术的区别" class="headerlink" title="5. 与TrustZone技术的区别"></a>5. 与TrustZone技术的区别</h5><p><img src="https://img-blog.csdnimg.cn/20210529153405434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>TrustZone技术是一种安全执行区域概念，是<strong>芯片运行状态在共享资源、总线系统的安全态与非安全态</strong>的问题。基于TrustZone技术的<strong>TEEOS</strong>，形成一个可信执行环境，能够执行某些操作、保护某些资源。</p><p>PUF可以被用作<strong>唯一且不可篡改的设备标识符</strong>。PUF也可以用于安全密钥生成和存储以及随机源。</p><h3 id="二、SRAM-PUF特点"><a href="#二、SRAM-PUF特点" class="headerlink" title="二、SRAM PUF特点"></a>二、SRAM PUF特点</h3><h5 id="1-SRAM-PUF"><a href="#1-SRAM-PUF" class="headerlink" title="1. SRAM PUF"></a>1. SRAM PUF</h5><p>深亚微米工艺上来说，制造过程中随机因素会影响电路特性，从而导致Cell上电时，0与1随机分布，这个随机分布，基本上是固定的分布，这样可以提取出PUF值<br><img src="https://img-blog.csdnimg.cn/20210529160021982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="2-SRAM-PUF-Key存储"><a href="#2-SRAM-PUF-Key存储" class="headerlink" title="2. SRAM PUF Key存储"></a>2. SRAM PUF Key存储</h5><p>PUF Key在芯片生命周期使用阶段：</p><ol><li><p><strong>Enrollment——QTP</strong>(One Time Process)<br><img src="https://img-blog.csdnimg.cn/2021052916031822.png" alt="在这里插入图片描述"><br>从SRAM PUF中提取R值，经过PUF-IP，再经过AC过程（用于纠错），然后配合上电过程完成启动</p></li><li><p><strong>Key重构</strong>——每次上电都需要重新执行这个过程<br>R’值和之前R值是不一样的，由于芯片SRAM Cell 80%0,1值是确定的，但是也有少部分是随机变化的。通过AC纠错，可以保证每次SRAM生成的PUF Key是固定的。<br><img src="https://img-blog.csdnimg.cn/20210529160559890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>前提条件</strong>：<br><img src="https://img-blog.csdnimg.cn/20210529160811663.png" alt="在这里插入图片描述"><br>a. AC和Key相关性是0，即从ACcode是无法推导出PUF key<br>b. 提取出的Key值需要达到一定的可靠性</p></li></ol><h5 id="3-SRAM-PUF-产品形态"><a href="#3-SRAM-PUF-产品形态" class="headerlink" title="3. SRAM PUF 产品形态"></a>3. SRAM PUF 产品形态</h5><ol><li><p>软件形态</p></li><li><p>硬件IP形态<br><img src="https://img-blog.csdnimg.cn/20210529161152979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="4-SRAM-PUF生命使用周期"><a href="#4-SRAM-PUF生命使用周期" class="headerlink" title="4. SRAM PUF生命使用周期"></a>4. SRAM PUF生命使用周期</h5><p>软件的BROADKEY可以部署至各个生命周期的芯片上，<br><img src="https://img-blog.csdnimg.cn/20210529162213900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以保障25年的生命周期</p></li><li>可靠性</li><li>制造型</li><li>安全认证<br><img src="https://img-blog.csdnimg.cn/20210529162320386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h3 id="三、SRAM-PUF应用"><a href="#三、SRAM-PUF应用" class="headerlink" title="三、SRAM PUF应用"></a>三、SRAM PUF应用</h3><h5 id="1-生成应用Key流"><a href="#1-生成应用Key流" class="headerlink" title="1. 生成应用Key流"></a>1. 生成应用Key流</h5><p>与SRAM PUF流程一致</p><ol><li>Enrollment</li><li>Key 重构<br><img src="https://img-blog.csdnimg.cn/20210529162523286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h5 id="2-Wrap-Operation"><a href="#2-Wrap-Operation" class="headerlink" title="2. Wrap Operation"></a>2. Wrap Operation</h5><p>与之前一种的区别是，这次的Key值不作为应用密钥，<br>而是作为应用密钥的加密密钥来使用</p><ol><li><p>Enrollment<br><img src="https://img-blog.csdnimg.cn/20210529162823451.png" alt="在这里插入图片描述"></p></li><li><p>Key 编程<br><img src="https://img-blog.csdnimg.cn/20210529162833386.png" alt="在这里插入图片描述"></p></li><li><p>Key重构<br><img src="https://img-blog.csdnimg.cn/20210529162841362.png" alt="在这里插入图片描述"></p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210529162758116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="3-防克隆的应用方案"><a href="#3-防克隆的应用方案" class="headerlink" title="3. 防克隆的应用方案"></a>3. 防克隆的应用方案</h5><p><strong>安全固件的导入：</strong></p><ol><li><p>BROADKEY集成在bootloader中，含有两个内容，一个是Bootloader，另外一个为存储密钥，为固件的解密密钥。除了部件以外，还有加解密库。<br><img src="https://img-blog.csdnimg.cn/20210529163535631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>把这个固件download到产品的flash中，然后需要通过<strong>BROADKEY</strong>把 <strong>AC code</strong>提取出来，存储到数据区<br><img src="https://img-blog.csdnimg.cn/20210529163606552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li>将BROADKEY生成Key将固件的<strong>解密密钥进行加密</strong>以后，存储到flash数据区<br><img src="https://img-blog.csdnimg.cn/20210529163741262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>用固件的解密密钥将初始导入的加密固件解密出来，存储至可执行区域中<br><img src="https://img-blog.csdnimg.cn/20210529163917535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>因为固件已经解密完成，因此把bootloader中的解密密钥删除，同时导入固件的加密密钥也可以删除<br><img src="https://img-blog.csdnimg.cn/2021052916401965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>最后，用PUF Key生成MAC值，存储到数据区，以上为安全固件的导入过程<br><img src="https://img-blog.csdnimg.cn/20210529164422385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>使用过程</strong>：<br>a. 在安装过程中，固件已经装好。<br>b. 芯片上电后，bootloader可以都会AC code<br>c. 同时生成PUF key，同时利用PUF key来对固件进行计算，同时与之前MAC值进行比较。如果正确则可以执行固件，比较错误，则会进入错误状态。<br><img src="https://img-blog.csdnimg.cn/20210529164930340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>固件升级</strong><br><img src="https://img-blog.csdnimg.cn/20210529165054791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>防克隆原理</strong><br><img src="https://img-blog.csdnimg.cn/20210529165200374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果将芯片中固件放入另一个固件，即使两个芯片完全一样。<br>每次上电中，BROADKEY则会提取出PUF Key，如果芯片一旦换了之后，读取AC code进行PUF Key的提取，就会发现AC code并不是芯片本身的AC code，所以会报错。则会影响下一步的过程。因此，可以防克隆的攻击。</li></ol><h3 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h3><p>SRAM PUF的特征</p><ol><li>可以容易的加载PUF  key的功能</li><li>很高的可靠性，可以保证小于 $10^{-12}$ 错误概率</li><li>很好的工艺适配性（7nm~.13um的工艺）</li><li>安全认证高</li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hardware Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件安全技术——芯片安全设计技术3</title>
      <link href="/posts/675868658655754.html"/>
      <url>/posts/675868658655754.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、硬件安全解决方案"><a href="#一、硬件安全解决方案" class="headerlink" title="一、硬件安全解决方案"></a>一、硬件安全解决方案</h3><h5 id="1-为什么需要硬件安全"><a href="#1-为什么需要硬件安全" class="headerlink" title="1. 为什么需要硬件安全"></a>1. 为什么需要硬件安全</h5><ol><li>安全是系统级的，如果只是软件进行安全防护，那么<strong>无法建立强有力的信任根</strong></li><li>Crypto Engine只是解决了<strong>密码计算问题</strong>，只是单纯的拼凑组合是无法组成安全系统的</li><li>各种<strong>高等级的认证</strong>要求底<strong>层的核心安全，密码实现</strong>需要由硬件来完成参与</li></ol><h5 id="2-传统安全解决方案对比"><a href="#2-传统安全解决方案对比" class="headerlink" title="2. 传统安全解决方案对比"></a>2. 传统安全解决方案对比</h5><p>三种方法：MCU，TEE，SE<br>方案无好坏之分，只有是否符合系统的应用场景来选择解决方案<br><img src="https://img-blog.csdnimg.cn/20210529112656464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="3-SoC安全解决方案"><a href="#3-SoC安全解决方案" class="headerlink" title="3. SoC安全解决方案"></a>3. SoC安全解决方案</h5><ol><li>将<strong>传统的SE的功能集成到SoC中</strong>，避免了<strong>板级走线</strong>带来的安全风险</li><li><strong>避免了外部的数据传输性能的瓶颈</strong>，可以作为加速器使用</li><li><strong>无需额外的芯片，降低了整体成本</strong></li><li>目前手机AP厂商大多数使用该解决方案<h3 id="二、Root-of-Trust（信任根）"><a href="#二、Root-of-Trust（信任根）" class="headerlink" title="二、Root of Trust（信任根）"></a>二、Root of Trust（信任根）</h3><h5 id="1-信任根（RoT）是建立信任链的来源，也是SoC中安全根基"><a href="#1-信任根（RoT）是建立信任链的来源，也是SoC中安全根基" class="headerlink" title="1. 信任根（RoT）是建立信任链的来源，也是SoC中安全根基"></a>1. 信任根（RoT）是建立信任链的来源，也是SoC中安全根基</h5>其涉及<strong>安全启动</strong>、<strong>密钥管理</strong>两部分<h5 id="2-安全启动"><a href="#2-安全启动" class="headerlink" title="2. 安全启动"></a>2. 安全启动</h5></li><li>硬件负责<strong>初始化</strong>安全启动过程中需要使用的<strong>模块</strong>，例如<strong>随机数发生器、安全传感器、NVM控制器</strong>等</li><li><p>CPU从自身ROM中读取一级启动代码，对外部的二级Bootloader <strong>进行解密和验签</strong>，确保二级Bootloader的完整性和认证性<br><img src="https://img-blog.csdnimg.cn/2021052911392989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="3-密钥管理"><a href="#3-密钥管理" class="headerlink" title="3. 密钥管理"></a>3. 密钥管理</h5></li><li><p>保护密钥的<strong>机密性</strong>，密钥一般存储在NVM中</p></li><li>确认密钥的<strong>完整性</strong></li><li>提前考虑各种角色，确保在实际场景中的<strong>可用性</strong></li><li>结合芯片<strong>生命周期</strong>管控烧写、使用、debug相关权限<h3 id="三、关键安全模块"><a href="#三、关键安全模块" class="headerlink" title="三、关键安全模块"></a>三、关键安全模块</h3><h5 id="1-MPU-MMU"><a href="#1-MPU-MMU" class="headerlink" title="1. MPU/MMU"></a>1. MPU/MMU</h5>访问地址、权限隔离<h5 id="2-Crypto-Engine"><a href="#2-Crypto-Engine" class="headerlink" title="2. Crypto Engine"></a>2. Crypto Engine</h5></li><li>提供各种秘钥运算的支持</li><li>提升秘钥运算的性能和安全性</li><li><strong>避免软件可以访问关键秘钥</strong>，<strong>高等级的安全认证密钥硬件化</strong><h5 id="3-Detector"><a href="#3-Detector" class="headerlink" title="3. Detector"></a>3. Detector</h5>探测环境的异常变化<br>当在攻击硬件时，可能需要通过升压，提高频率等措施，而当SoC系统中存在这些监控异常变化时，能够及早的预防这些异常变化，从而保护硬件安全。</li></ol><h5 id="4-Storage-Protection-Unit"><a href="#4-Storage-Protection-Unit" class="headerlink" title="4. Storage Protection Unit"></a>4. Storage Protection Unit</h5><p>保护<strong>存储单元</strong>内的数据，<strong>地址总线和数据总线</strong>都需要<strong>加密、加扰</strong></p><h5 id="5-Bus-Protection-Unit"><a href="#5-Bus-Protection-Unit" class="headerlink" title="5. Bus Protection Unit"></a>5. Bus Protection Unit</h5><p>保护总线上传输的信息，地址和数据都需要<strong>加扰</strong>(实时性比较高，一般只做加扰)</p><h5 id="6-Secure-Processor"><a href="#6-Secure-Processor" class="headerlink" title="6. Secure Processor"></a>6. Secure Processor</h5><ol><li>利用<strong>Memory Tagging等技术</strong>防止关于Memory的攻击</li><li>利用<strong>Time constant计数</strong>防止Timing Attack</li></ol><h3 id="四、安全系统的应用——-智能电表"><a href="#四、安全系统的应用——-智能电表" class="headerlink" title="四、安全系统的应用—— 智能电表"></a>四、安全系统的应用—— 智能电表</h3><ol><li>智能电表是<strong>IoT典型安全敏感应用</strong><ol><li>智能电表处于一个<strong>开放的不可控的环境</strong>下</li><li>只能电表覆盖量极大，并且与基础民生相关，有着很高的价值</li><li>智能电表是一个典型的基于<strong>MCU的SoC芯片</strong>，SoC中有着很多的<strong>防护措施保护RoT和运行安全</strong><br><img src="https://img-blog.csdnimg.cn/20210529145628722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol></li></ol><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><ol><li>安全系统方案多种多样，根据实际业务场景进行选择</li><li>单一模块无法保证系统安全，系统安全需要从<strong>硬件、软件、生产和使用</strong>统筹考虑</li><li><strong>RoT需要由硬件来实现从而达到不可篡改的特性</strong></li><li>随着新兴行业（IoT,5G）的发展，硬件安全的重视程度逐渐提升</li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hardware Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件安全技术——芯片安全设计技术2</title>
      <link href="/posts/465465754.html"/>
      <url>/posts/465465754.html</url>
      
        <content type="html"><![CDATA[<p>硬件安全技术——芯片安全设计技术2</p><h3 id="一、常见的公钥密码算法"><a href="#一、常见的公钥密码算法" class="headerlink" title="一、常见的公钥密码算法"></a>一、常见的公钥密码算法</h3><h5 id="1-公钥密码概述"><a href="#1-公钥密码概述" class="headerlink" title="1. 公钥密码概述"></a>1. 公钥密码概述</h5><ol><li>公钥密码学与1976年由Whitfield Diffe 、Martin Hellman和Ralph Merkle公开介绍</li><li>公钥密码计数是<strong>20世界最伟大的思想之一</strong><br>由于其改变了秘钥分发的方式<br>可以广泛应用于数字签名和身份认证服务</li><li>1977年提出的<strong>RSA</strong>成为以后使用最广泛的一种非对称密码算法</li></ol><h5 id="2-RSA密码算法"><a href="#2-RSA密码算法" class="headerlink" title="2.RSA密码算法"></a>2.RSA密码算法</h5><ol><li>1977年由Ronald Rivest、Adi Shamir和Leonard Adleman发明，1978年公布。算法名称取自作者的名字<strong>首字母</strong>。</li><li>1993年发布了<strong>PKCS#1标准</strong>来说明RSA的使用规范。2000年RSA专利到期（当时ECC专利还未到期）</li><li>如今，只有短的RSA秘钥才能被强力方式破解。到2019年为止，还没有任何可靠的攻击RSA算法的方式。<strong>RSA-2048至今是安全的</strong>。</li></ol><h5 id="3-RSA算法描述"><a href="#3-RSA算法描述" class="headerlink" title="3. RSA算法描述"></a>3. RSA算法描述</h5><p><img src="https://img-blog.csdnimg.cn/20210528160127885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解密的过程主要依赖欧拉函数来正确还原明文。</p><h5 id="4-ECC椭圆曲线算法"><a href="#4-ECC椭圆曲线算法" class="headerlink" title="4. ECC椭圆曲线算法"></a>4. ECC椭圆曲线算法</h5><ol><li>1985年由Neal Koblitz和Victor Miller分别独立提出</li><li>域K上的椭圆曲线E有下述方程定义：<br><img src="https://img-blog.csdnimg.cn/20210528161054867.png" alt="在这里插入图片描述"></li><li>有两种运算法则：<strong>倍点和点加</strong><br><img src="https://img-blog.csdnimg.cn/20210528163824473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><ul><li><strong>点乘</strong>运算可以转换为<strong>点加和倍点</strong>运算</li><li>主要运算为点乘，P和Q为椭圆曲线上的点，K为标量，Q=kP，<strong>知道P与Q，很难得到k</strong></li><li><p>点乘运算类似模幂运算<br>9（0b1001）P = 2<em>2</em>2P + P</p><ol><li>不同公钥算法安全级别对比<br><img src="https://img-blog.csdnimg.cn/20210528164609190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol></li></ul><h3 id="二、常见的使用场景"><a href="#二、常见的使用场景" class="headerlink" title="二、常见的使用场景"></a>二、常见的使用场景</h3><h5 id="1-非对称算法应用"><a href="#1-非对称算法应用" class="headerlink" title="1. 非对称算法应用"></a>1. 非对称算法应用</h5><ul><li><strong>签名、验签</strong>（常用）：<br>私钥用云签名，公钥用于验签，确认签名者的身份</li><li><strong>秘钥协商</strong><br>双方协商出一个共同的秘钥</li><li><strong>加密、解密</strong><br>公钥用于加密，私钥用于解密，该方式加解密代价较大</li></ul><h5 id="2-常见应用1——网络认证"><a href="#2-常见应用1——网络认证" class="headerlink" title="2. 常见应用1——网络认证"></a>2. 常见应用1——网络认证</h5><ol><li>客户端需要<strong>验证</strong>服务端的身份或者服务端验证客户端的身份，在<strong>双方验证完身份</strong>后，通过协商的密钥</li><li>在握手阶段需要进行<strong>验签、密钥交换</strong>操作<br><img src="https://img-blog.csdnimg.cn/20210528165209479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h5 id="3-常见应用2——安全启动"><a href="#3-常见应用2——安全启动" class="headerlink" title="3. 常见应用2——安全启动"></a>3. 常见应用2——安全启动</h5></li><li>目前越来越多的设备使用了安全启动来保护安全，防止固件等呗第三方篡改</li><li>验证固件、应用的签名，但验证失败，就无法进入下一个阶段<br><img src="https://img-blog.csdnimg.cn/20210528181116715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h5 id="4-常见应用3——V2X新应用领域"><a href="#4-常见应用3——V2X新应用领域" class="headerlink" title="4. 常见应用3——V2X新应用领域"></a>4. 常见应用3——V2X新应用领域</h5></li><li><strong>频繁</strong>对周围设备发来的位置信息<strong>进行验签</strong></li><li><strong>验签速度远远大于签名速度</strong>，验签速度大于在<strong>2000次每秒</strong></li><li>目前的规范大多使用了<strong>ECDSA</strong></li></ol><h5 id="5-常见应用4——嵌入式设备"><a href="#5-常见应用4——嵌入式设备" class="headerlink" title="5. 常见应用4——嵌入式设备"></a>5. 常见应用4——嵌入式设备</h5><ol><li><p>嵌入式设备通常都有mbedtls<br><img src="https://img-blog.csdnimg.cn/20210528181702205.png" alt="在这里插入图片描述"></p></li><li><p>mbedTLS软件包提供了如下的能力<br><img src="https://img-blog.csdnimg.cn/20210528181714899.png" alt="在这里插入图片描述"></p><h5 id="6-RSA、ECC的选择"><a href="#6-RSA、ECC的选择" class="headerlink" title="6. RSA、ECC的选择"></a>6. RSA、ECC的选择</h5></li><li><strong>RSA的验签素服可以做到很快</strong>（原因是私钥可以很短）<br>例如在安全启动的场景下，如果对启动速度很敏感则很有优势</li><li><strong>ECC的验签速度一般比签名速度慢</strong><br>如果使用ECDSA并且未经优化，签名速度一般是验签的速度的两倍</li><li><strong>RSA的存储占用远远大于ECC</strong><br>对SRAM敏感的场景下，建议使用ECC算法</li><li><strong>RSA的密钥生成速度远远小于ECC</strong></li></ol><h3 id="三、常见的抗攻击设计"><a href="#三、常见的抗攻击设计" class="headerlink" title="三、常见的抗攻击设计"></a>三、常见的抗攻击设计</h3><h5 id="1-点乘，模幂的防侧信道保护"><a href="#1-点乘，模幂的防侧信道保护" class="headerlink" title="1. 点乘，模幂的防侧信道保护"></a>1. 点乘，模幂的防侧信道保护</h5><ol><li><strong>点乘</strong></li></ol><ul><li>固定时间：蒙哥马利阶乘</li><li>标量掩码：标量加上阶的随机倍数</li><li>随机坐标：对投影坐标进行随机化处理</li></ul><ol><li>模幂</li></ol><ul><li>固定时间：蒙哥马利阶乘</li><li>指数掩码：对幂指数进行拆分（欧拉函数）</li><li>底数掩码：对底数乘上随机数，在得到最终结果前脱掩码</li></ul><h5 id="2-验签的防FI（错误注入）保护"><a href="#2-验签的防FI（错误注入）保护" class="headerlink" title="2. 验签的防FI（错误注入）保护"></a>2. 验签的防FI（错误注入）保护</h5><ol><li>硬件多次校验</li><li>多次校验之间使用随机延迟</li><li>如果使用了蒙哥马利阶乘，可以利用两数之间的关系进行校验</li><li>参数进行CRC校验<h3 id="四、非对称密码算法实现"><a href="#四、非对称密码算法实现" class="headerlink" title="四、非对称密码算法实现"></a>四、非对称密码算法实现</h3><h5 id="1-层次化设计"><a href="#1-层次化设计" class="headerlink" title="1. 层次化设计"></a>1. 层次化设计</h5></li><li>根据运算调用关系进行分层<br>底层的适合用硬件来处理，顶层的适合使用软件来处理<br><img src="https://img-blog.csdnimg.cn/2021052821004735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><ul><li>底层的运算被调用频率高，使用硬件有利于增加运算效率</li><li>顶层协议级运算考虑使用软件设计以增加灵活性，但需要考虑硬件的中断设计，在硬件运算时可以释放CPU资源</li></ul><h5 id="2-选取适合的坐标系"><a href="#2-选取适合的坐标系" class="headerlink" title="2.选取适合的坐标系"></a>2.选取适合的坐标系</h5><ol><li><p>标准摄影坐标系<br><img src="https://img-blog.csdnimg.cn/20210528210421217.png" alt="在这里插入图片描述"></p></li><li><p>雅可比（Jacobian）坐标系<br><img src="https://img-blog.csdnimg.cn/20210528210432188.png" alt="在这里插入图片描述"></p><h5 id="3-预计算加速（软件实现比较多）"><a href="#3-预计算加速（软件实现比较多）" class="headerlink" title="3.预计算加速（软件实现比较多）"></a>3.预计算加速（软件实现比较多）</h5></li><li><p>对基点进行预计算<br><img src="https://img-blog.csdnimg.cn/20210528210645598.png" alt="在这里插入图片描述"></p></li><li><p>OpenSSL的预计算优化<br><img src="https://img-blog.csdnimg.cn/20210528210656895.png" alt="在这里插入图片描述"></p><h6 id="4-利用SIMD指令进行加速"><a href="#4-利用SIMD指令进行加速" class="headerlink" title="4.利用SIMD指令进行加速"></a>4.利用SIMD指令进行加速</h6></li><li>各家都有自己的SIMD指令<br>Intel:AXV2/SSE<br>ARM:NEON</li><li>利用SIMD特性，能够使运算提升数倍<br><img src="https://img-blog.csdnimg.cn/20210528211159104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3></li><li>公钥算法用于<strong>身份识别</strong>，主要应用为<strong>签名和验签</strong></li><li><strong>ECDSA/ECDH和RSA</strong>是主流的公钥密码体系中的算法，<strong>SM2</strong>是国内主要的公钥密码算法</li><li>公钥密码算法往往<strong>有吞吐数据量小</strong>，<strong>运算时间长</strong>的特性</li><li>由于公钥算法比较复杂，可以优先考虑已有的实现，避免反复造轮子。但要有优势，<strong>软硬件结合</strong>是最好的方式。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hardware Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件安全技术——芯片安全设计技术1</title>
      <link href="/posts/e945235245.html"/>
      <url>/posts/e945235245.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、常见的对称算法"><a href="#一、常见的对称算法" class="headerlink" title="一、常见的对称算法"></a>一、常见的对称算法</h3><ol><li><strong>对称密码算法</strong><br>加密和解密的秘钥是一样的<br>加密过程：X是明文，K是秘钥，Y是密文<br>解密过程：Y是密文，K是秘钥，X是明文<br><img src="https://img-blog.csdnimg.cn/20210527223926475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_5,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>常见的对称算法</strong></li></ol><ul><li>AES (Advanced Encryption Standard)</li><li>DES/3DES (Data Encryption Standard)</li><li>SM4</li><li>ZUC</li><li><p>Chacha20</p><p>  按照字节来划分，前三种AES,DES, SM4可分为一类，均按照8、16字节来分组，又称为<strong>分组密码</strong>。</p><p>  对于ZUC，Chacha20则没有分组，又称为<strong>流密码</strong>。</p></li></ul><ol><li><strong>AES分组密码算法</strong><br>AES是目前国际使用最为广泛的对称密码算法<br>其算法流程为：<br><img src="https://img-blog.csdnimg.cn/20210527225009279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>AES算法有三个子类，分别为<strong>AES128、AES-192、AES-256</strong>。<br>区别：<br><strong>秘钥长度</strong>：128,192,256<br><strong>轮数</strong>：10,12,14<br>加解密的<strong>黑盒子SBOX</strong>不同<br>加解密使用<strong>轮秘钥的顺序</strong>不同</li></ol><h3 id="二、常见的使用模式与场景"><a href="#二、常见的使用模式与场景" class="headerlink" title="二、常见的使用模式与场景"></a>二、常见的使用模式与场景</h3><ol><li><p><strong>分组密码操作模式</strong><br><strong>ECB模式（电子密码本模式）</strong><br>在实际中，，加密数据往往大于8字节，16字节，最简单的方式就是将数据分割为若干个分组后，对这些分组数据分别进行加密，也就是ECB模式。</p><p> 关于操作模式说明：对于很长的数据，如1M，那么使用SM4,AES等对称密码算法，输入只能为固定字节数，如8字节或16字节。那么最简单的解决方式即为ECB模式。<br><img src="https://img-blog.csdnimg.cn/20210527225511414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>ECB模式的缺点：采用ECB模式及每个数据都分别进行加密，各个加密之间互不干扰，因此，可以从密文中可以看出对应的结构变化趋势，这对于抵抗攻击来说是不安全的。<br>类似于一个模糊的图片，虽然被加密了，但还是能够看出其中的一些信息：<br><img src="https://img-blog.csdnimg.cn/20210527225915116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><strong>CBC模式</strong><br>为了解决ECB模式的缺点，此外还有其他的模式，如CBC模式：<br><img src="https://img-blog.csdnimg.cn/20210527230135501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于CBC加密过程，每一个分组异或后会与上一个得到的结果，在进行下一次的黑盒运算。这样可以打乱每一个分组的结构信息。</p></li><li><p><strong>常见的对称算法加密模式</strong></p></li></ol><ul><li><strong>ECB</strong>-Electronic Code Book </li><li><strong>CBC</strong>-Cipher Block Chaining</li><li><strong>CTR</strong>-CounTeR</li><li><strong>GCM</strong>-Galois/Counter，用于网络通信</li><li><strong>XTS</strong>-XEX-based Tweaked-codebook mode with ciphertext Stealing，用于数据存储</li></ul><ol><li><p><strong>数据存储</strong><br>安卓7.0以及更高的版本支持<strong>文件级别的加密（FBE）</strong>。采用文件级加密时，可以使用不同的秘钥对不同的文件进行加密，也可以对加密的文件单独解密。<br><img src="https://img-blog.csdnimg.cn/20210528102704939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 所有加密都基于<strong>采用XTS模式的AES-256算法</strong>。内核的加密性能必须要在使用AES XTS时至少达到<strong>50MB/s</strong>，以确保良好的用户体验。</p><p> 因为在使用数据存储加密时，会带来性能上的瓶颈，造成性能变差，因此需要对加密的算法提出合理的要求来达到良好的用户体验。</p></li><li><p><strong>数据存储的常用模式-XTS</strong><br><img src="https://img-blog.csdnimg.cn/20210528103403976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>特点：</p></li></ol><ul><li>NIST SP800-38E (标准化模式)</li><li>无需IV,初始向量（与CBC模式不同）</li><li>i为sector number（与数据处理的位置相关）</li><li>可以随机访问</li><li>可以进行并行处理</li></ul><ol><li><strong>网络通信</strong></li></ol><ul><li>SSL/TLS（Secure Socket Layer 安全套接层）是基于HTTPS下的一个协议加密层</li><li>TLS通信中数据都会使用对称密码算法进行加密，密码算法的种类在握手阶段进行确认</li><li>TLS-AES-128-GCM-SHA256为TLS v1.3的必选算法<br><img src="https://img-blog.csdnimg.cn/20210528104103190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><ol><li><strong>网络通信加密中常见的模式——GCM模式</strong><br><img src="https://img-blog.csdnimg.cn/20210528105141149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>特点</li></ol><ul><li>NIST SP800-38D(标准)</li><li>即可以对数据加密，也可以用于提供校验值（auth tag）</li><li>处理速度可以比CBC快，因为加解密部分可以并行处理。</li></ul><h3 id="三、常见的抗攻击设计"><a href="#三、常见的抗攻击设计" class="headerlink" title="三、常见的抗攻击设计"></a>三、常见的抗攻击设计</h3><ol><li><strong>侧信道攻击防护</strong></li></ol><p><strong>思想1</strong>：对中间值进行随机化或掩码。<br><img src="https://img-blog.csdnimg.cn/2021052810540569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对<strong>中间值</strong>进行<strong>随机化处理</strong>，往往通过对中间值异或或掩码来达到随机化中间过程的目的：</p><ul><li><strong>线性操作</strong>往往使用<strong>布尔掩码</strong></li><li><strong>非线性操作</strong>使用<strong>乘法掩码、随机掩码和国定值掩码</strong></li></ul><p><strong>思想2</strong>：增加随机延迟或伪操作<br>    在功耗上无法区别延迟或者伪操作，使得攻击者无法<strong>对齐功耗曲线</strong>。<br>    <img src="https://img-blog.csdnimg.cn/20210528113405447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li><strong>FI防护（错误注入分析防护）</strong></li></ol><ul><li><p><strong>多次操作校验是否计算结果相同</strong></p><ul><li>可以使用加密后解密来判断明文是否一致，对运算<strong>前后几轮</strong>需要重点关注</li></ul></li><li><p><strong>关键参数保存CRC</strong></p><ul><li>例如秘钥的CRC值可以由硬件保存，不定时计算目前使用的秘钥CRC值是否一致<h3 id="四、对称密码算法实现"><a href="#四、对称密码算法实现" class="headerlink" title="四、对称密码算法实现"></a>四、对称密码算法实现</h3></li></ul></li></ul><ol><li><p><strong>SBOX黑盒设计实现策略</strong><br>硬件上游两种主要实现方案：<br> a. <strong>使用查找表</strong><br> b. <strong>二项式求逆</strong><br><img src="https://img-blog.csdnimg.cn/20210528114256494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> SMIC55, 100MHz，上面的是查找表实现，下面的是二项式求逆实现。可以看到查找表实现的面积大约为其一倍。一般是频率越高，二项式求逆的面积越小，因此，需要权衡面积和性能的关系（trade-off）。</p></li><li><p><strong>轮秘钥的计算逻辑</strong><br>使用两个寄存器来存储轮秘钥，regA存储第一轮或最后一轮轮秘钥，regB用于存储当前的轮秘钥(非高速应用中)</p><p> 需要有标识标志regA存储的为第一轮还是最后一轮轮秘钥</p><p> 在一个时钟周期只进行一轮（或较少轮数）运算时，避免在一开始就讲坤秘钥全部扩展完成，占用大量寄存器。</p></li><li><p><strong>密钥管理</strong><br><strong>关键密钥</strong>：关键密钥由硬件管理，软件不可见或控制访问权限，例如<strong>根密钥</strong>。</p><p> <strong>应用密钥</strong>：应用密钥由软件协调管理，增加灵活性，例如<strong>会话秘钥</strong>。</p></li></ol><p>4.<strong>指令集加速</strong><br>通过查看CPU信息来确认是否支持指令集加速</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">user@root:grep aes -o -ml &#x2F;proc&#x2F;cpuinfoaes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>openssl 1.0.1版本后，运行时期自动检测是否支持AES-NI<br>只有使用openssl EVP的接口，定义函数才能使用AES-NI</p><p>如果CPU支持AES-NI指令扩展，其性能如下：<br><img src="https://img-blog.csdnimg.cn/20210528145911921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="五、总结："><a href="#五、总结：" class="headerlink" title="五、总结："></a>五、总结：</h3><ol><li>根据应用场景选择适合的算法和模式，根据标准规范使用</li><li>大多数算法还是可以使用空间换时间的方式进行加速</li><li>物理安全设计包含前端、后端整个IC设计流程，安全性措施在设计完成后还需要经过过实验室测试</li><li>常用的硬件对密码算法往往有加速支持</li></ol>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hardware Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件安全技术——概述1(安全威胁和硬件安全技术)</title>
      <link href="/posts/e9913346.html"/>
      <url>/posts/e9913346.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、硬件安全技术是什么？"><a href="#一、硬件安全技术是什么？" class="headerlink" title="一、硬件安全技术是什么？"></a>一、硬件安全技术是什么？</h3><ol><li>传统视角：<br><strong>硬件安全</strong>=<strong>密码芯片安全</strong>，特别是智能卡、可信计算、Ukey等芯片攻击防御技术<br><img src="https://img-blog.csdnimg.cn/20210525101630337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><p>密码芯片的逻辑接口、物理接口安全；<br>核心功能：具备防攻击能力，能有效<strong>保护秘钥存储</strong>、进行<strong>安全密码运算</strong>；<br><img src="https://img-blog.csdnimg.cn/20210525101647538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>密码芯片是一个边界清楚，作为一个黑盒子，放在系统中，起到安全密码运算、防攻击等功能。</p><h3 id="二、智联时代"><a href="#二、智联时代" class="headerlink" title="二、智联时代"></a>二、智联时代</h3><ol><li><p><strong>万物互联+智能化</strong>：<br><strong>云、端协作、数字孪生、海量数据</strong>，如智能家居、智慧城市、电力网络等迈向智能时代。<br><img src="https://img-blog.csdnimg.cn/20210525102349529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><strong>网络攻击进入物理世界</strong>:<br><strong>攻击截面扩大，风险巨大</strong>，如黑客操控物理世界产品，威胁从“谋财”升级为“害命”<br><img src="https://img-blog.csdnimg.cn/20210525102438471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因此，需要相关的技术来解决安全问题。</p></li></ol><h3 id="三、真实世界安全问题层出不穷"><a href="#三、真实世界安全问题层出不穷" class="headerlink" title="三、真实世界安全问题层出不穷"></a>三、真实世界安全问题层出不穷</h3><ol><li>监控摄像头的攻击</li><li>智能音箱攻击</li><li>服务器攻击</li><li>个人电脑攻击</li><li>电力、网络攻击<br><img src="https://img-blog.csdnimg.cn/20210525102655659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><p>如何减少这类事件的发生，因此，硬件安全技术可以有效的解决这类事件发生的概率。</p><h3 id="四、硬件安全：新视角"><a href="#四、硬件安全：新视角" class="headerlink" title="四、硬件安全：新视角"></a>四、硬件安全：新视角</h3><p><img src="https://img-blog.csdnimg.cn/20210525110558968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解决安全问题，可以分为四个部分来进行问题解决：<br>应用软件，操作系统，底层软件，硬件层（如硬件电路）</p><p>系统和固件是密不可分；<br>系统信任跟由硬件+底层软件共同保护；<br>如果底层有漏洞，那么系统肯定会被破解；</p><p>因此，硬件安全研究不仅仅局限传统的独立密码芯片研究范畴，现在考虑的是在更复杂的、开放的系统中，硬件安全能够做什么？<br>传统的硬件安全保护秘钥，未来的硬件安全除了要保护秘钥，还要保护软件，再由软件再保护上层应用。</p><p>硬件安全用在什么地方，所有联网的设备，必须用到硬件安全技术</p><p>举一个简单的IoT例子：（物联网设备、智能手机、云）<br><img src="https://img-blog.csdnimg.cn/20210525111239815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>设备端：</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">固件保护身份识别数据加解密其他<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>手机端：</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">OSAPP安全生物识别安全其他<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>云端</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">网络安全租户OS安全数据安全其他<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>硬件安全扮演的角色：<br>虽然云和端所用的芯片架构不一样，如算力、软件等。但是却有相同的硬件安全要求。<br>例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">1. 硬件需要提供安全的Boot ROM。芯片启动第一步，信任根2. 安全秘钥、ID的管理3. 加解密、签名、密码运算等秘钥安全信息4. 随机数发生器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于手机端，可能还有<strong>安全执行环境</strong>，需要run应用，如指纹、人脸。<br>对于云端，考虑运行在<strong>虚拟机上的多个用户安全需求</strong>，如每个用户可能有自己秘钥存储需求；<strong>OS的安全启动</strong>、<strong>数据安全</strong>需求；<strong>TLS的卸载</strong>等</p><h3 id="五、生命周期安全设计"><a href="#五、生命周期安全设计" class="headerlink" title="五、生命周期安全设计"></a>五、生命周期安全设计</h3><p>生命周期安全设计是硬件安全需要考虑的重点内容。<br><img src="https://img-blog.csdnimg.cn/20210525112749239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>实际在芯片的最初的RTL设计，到交付至用户的，存在很多环节。很多环节有可能导致秘钥、固件或者其他敏感信息的泄露，那么<strong>硬件安全如何在开放的供应链上构建信任根和信任链</strong>？这一点是硬件安全需要解决的问题。</p><h3 id="六、硬件安全技术"><a href="#六、硬件安全技术" class="headerlink" title="六、硬件安全技术"></a>六、硬件安全技术</h3><p><img src="https://img-blog.csdnimg.cn/20210525113107621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>硬件安全上主要研究内容可分为以下四个部分：</p><ol><li>硬件安全架构</li><li>物理攻击技术</li><li>抗攻击设计</li><li>面向软件安全的硬件设计</li></ol><h3 id="七、侧信道攻击"><a href="#七、侧信道攻击" class="headerlink" title="七、侧信道攻击"></a>七、侧信道攻击</h3><ol><li><p>侧信道攻击<br><img src="https://img-blog.csdnimg.cn/20210526100014630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210526100034348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>SCA本质上利用芯片在计算时，边信道的泄露，内部的电路的状态取决于算法的设计，例如对于8bit的寄存器，若初始值为0，一旦我们往里面写入一个字节的数据，那么在写入的过程中，部分寄存器的状态会翻转，即会引起功耗的变化（电容）。实际上，这种泄露是很危险的，并且在电路中一直存在的。</p><p> 侧信道的攻击对象发展有经历了如下过程：<br><img src="https://img-blog.csdnimg.cn/20210526100748674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一直存在的误解是，人们经常认为侧信道攻击只是对工艺落后的芯片才能进行攻击，却认为对面积大、工艺先进的芯片没有威胁，实际上这个观点是错误的，只要芯片在做密码相关的计算，就可能存在侧信道信息的泄露。</p></li><li><p><strong>侧信道攻击的分类</strong><br>除了从<strong>瞬时功耗</strong>的角度发现了可以攻击密码芯片外，此外还有<strong>电磁辐射</strong>，<strong>光子泄露</strong>，<strong>计算时间</strong>等侧信道的信息。</p><p> 侧信道攻击不需要破坏芯片或者修改软件，就可以攻击，因此其<strong>攻击门槛低，威胁较大</strong>。</p><p> 因此，<strong>抵抗侧信道攻击</strong>是安全芯片的主要的技术难点之一。</p></li></ol><h3 id="八、微架构侧信道（MASCA）"><a href="#八、微架构侧信道（MASCA）" class="headerlink" title="八、微架构侧信道（MASCA）"></a>八、微架构侧信道（MASCA）</h3><p>侧信道的其中一个分支为微架构侧信道，最近几年比较热门的侧信道。<br>微架构侧信道分析：利用处理器架构的特点，获取与敏感信息（如秘钥）相关的信息泄露（如时间），来破解系统安全防护。<br><img src="https://img-blog.csdnimg.cn/20210526101452558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如2017年，熔断和幽灵：滥用CPU推演执行功能，来构造攻击场景，对大量intel CPU均有效；<br>2018年，Foreshadow：滥用CPU推演执行破解了SGX;<br>2019年，NCC 高通 QSEE攻击：利用分支预测和cache的时序泄露，获得Trustzone之中的ECDSA私钥。</p><p>传统的攻击是需要黑客去靠近设备来达到攻击的目的，不能够批量的攻击设备，但是微结构侧信道攻击可以远程进行批量攻击。</p><h3 id="九、公钥密码算法"><a href="#九、公钥密码算法" class="headerlink" title="九、公钥密码算法"></a>九、公钥密码算法</h3><p>公钥算法的演进：<br><img src="https://img-blog.csdnimg.cn/2021052610294824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="十、硬件安全的内在挑战"><a href="#十、硬件安全的内在挑战" class="headerlink" title="十、硬件安全的内在挑战"></a>十、硬件安全的内在挑战</h3><p><img src="https://img-blog.csdnimg.cn/20210526105832382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>硬件安全设计和其他信息安全设计一样，也面临着内在的挑战。<br>首先，随着时间推移，新的攻击方法、新工具也会层出不穷，攻击者会变得越来越强，但是产品并不会变得更加抗攻击。<br>其次，设备所在的系统会更加复杂，包括网络结构、芯片架构、软件应用等。</p><p>因此，在安全设计时，<strong>最小化的安全假设，同时保持足够的功能和架构的安全性</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hardware Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件安全技术——概述2(5G时代IoT环境下芯片安全风险与挑战)</title>
      <link href="/posts/e9954737564.html"/>
      <url>/posts/e9954737564.html</url>
      
        <content type="html"><![CDATA[<p>上一节中主要介绍了关于硬件安全技术和安全威胁的概述，本次主要介绍<strong>5G时代背景下IoT环境下芯片安全风险与挑战</strong>。</p><h3 id="一、5G时代下的IoT"><a href="#一、5G时代下的IoT" class="headerlink" title="一、5G时代下的IoT"></a>一、5G时代下的IoT</h3><ol><li><p>5G时代下的IoT——终端数量爆发式的增长<br><img src="https://img-blog.csdnimg.cn/20210526155349968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 随着5G技术的发展，<strong>大数据量、低延时的通讯</strong>成为可能，这给物联网世界带来了迅猛的发展，<strong>智慧交通、智慧医疗、智慧电网</strong>，这些年逐步走进生活成为现实。</p><p> 爆炸式的终端互联，已经进入每一个家庭。到2019年，消费物联网终端数量已经达到了60亿规模，工业物联网终端超过50亿。</p><p> 按照终端使用情况，我们可以把终端分为三类：<br>消费性物联网终端；<br>公共性物联网终端；<br>生产性物联网终端；</p><p> 。 <strong>5G，AI，智能IoT</strong>的有机结合是物联网终端设备发展的趋势。但是这三者的结合会带来安全性的问题。</p></li><li><p><strong>5G时代下的IoT智慧应用分层</strong><br><img src="https://img-blog.csdnimg.cn/2021052616140353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>整个IoT的体系是非常庞大的。对于每一个环节都需要去考虑其中的风险性和安全性的问题。<br>IoT给我们的生活的确带来了很多便利，但是需要注意的是，如果存在坏人或不发分子时，对我们的应用层进行修改，比如，智慧安防等，则对我们的生活带来可怕的影响。</p></li><li><p><strong>IoT智慧应用建设特点——复杂，管控难</strong><br>IoT具有复杂的系统，技术和安全参差不齐，方案各异。</p><p> <strong>安全系统集成安全<br> 代码安全控制<br> 设备可信管理<br> 安全溯源机制<br> 系统可信传递<br> 数据可信共享</strong></p><p> 针对这些复杂的问题，国际和我国均<strong>制定相应的标准</strong>来约束我们供应商的的设计产品的参数。</p></li><li><p><strong>IoT云-管-端各处的安全防御要点（腾讯物联网安全技术规范）</strong><br><img src="https://img-blog.csdnimg.cn/2021052616215656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li>总结<br><strong>IoT设备数量爆炸，不可能做到每一个设备都进行测试与管控，但是我们可以通过对设备使用芯片的安全管控来达到整体安全提升的目的。并且会有专门的第三方认证机构进行安全认证，国家在这块已经有响应的参考标准与实验室来支持。<br> IoT的供应链极长，供应链安全的管理也是其中重点部分，为来区块链的应用也许会大量落地。</strong></li></ol><h3 id="二、IoT产品面临的实际威胁"><a href="#二、IoT产品面临的实际威胁" class="headerlink" title="二、IoT产品面临的实际威胁"></a>二、IoT产品面临的实际威胁</h3><p>互联网安全事件的安全威胁的一些例子：<br>物联网<br><img src="https://img-blog.csdnimg.cn/20210526222602374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>IoT终端设备安全需求：<br><img src="https://img-blog.csdnimg.cn/20210526222747253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="三、如何做好芯片的核心防护"><a href="#三、如何做好芯片的核心防护" class="headerlink" title="三、如何做好芯片的核心防护"></a>三、如何做好芯片的核心防护</h3><ol><li><p>芯片的核心资产<br><strong>芯片服务于应用，芯片安全最终是为了防护应用信息安全</strong>，如以下几个部分：<br><img src="https://img-blog.csdnimg.cn/20210526222857955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>芯片安全设计需要遵循响应的规范</p></li><li><p>以秘钥和密码算法来武装芯片系统<br>合理的<strong>秘钥和密码算法</strong>的设计赋予了芯片安全基石，结合硬件隔离技术简历整个芯片安全系统<br><img src="https://img-blog.csdnimg.cn/20210526223138220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>以方案将应用于芯片串联起来<br>以AI芯片防护为例，使用安全方案将芯片的安全属性付给AI的敏感信息<br><img src="https://img-blog.csdnimg.cn/20210526223320267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.以标准出发安全设计<br><img src="https://img-blog.csdnimg.cn/20210526223507997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从应用领域出发，引出相关标准、认证，从认证，标准出发设计定义安全芯片；</p><p> 以安全芯片为核心安全能力模块，向上满足响应的标准与认证，从而满足各个应用的安全；</p><p> 当没有行业标准的时候，请参考通用的安全标准，例如<strong>国密芯片，密码模块</strong>等标准。</p></li><li><p>以国密标准出发的安全设计<br><img src="https://img-blog.csdnimg.cn/20210526223820621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol><p><img src="https://img-blog.csdnimg.cn/2021052622384797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hardware Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学之公钥密码体系（1）：背包算法1</title>
      <link href="/posts/e9912263.html"/>
      <url>/posts/e9912263.html</url>
      
        <content type="html"><![CDATA[<p>密码学——公钥密码体系之背包算法1</p><p>众所周知，公钥密码，又称非对称密码，比较常见的是基于以下三种数学难题的公钥密码体制；</p><ol><li>大数因子分解难解性（RSA）</li><li>离散对数难解性（ElGamal）</li><li>椭圆曲线离散对数难解性（ECC）</li></ol><h3><span id="1背包算法">1.背包算法</span></h3><p>本次介绍的并不是以上三种类型的公钥密码体制，而是在公钥密码出现之前，就已经存在的公开密码加密算法：背包算法；<br>背包算法是由Merkle和Hellman开发的背包算法。只能用于加密，后来由Shamir将它改进，使之也能用于数字签名；</p><p>背包算法的安全性起源于背包难题，他是一个<strong>NP完全</strong>问题，但后来发现该算法并不安全，但是由于它证明了如何将NP完全问题用于公开秘钥密码学，因此，值得去学习。</p><p>下面介绍一下什么是背包算法：<br>描述：给定一个物品，每个重量不同，能否将这些物品中的几件放入一个背包中，使之等于一个给定的重量？<br>公式化描述：给定一系列值M1,M2，…，Mn，和一个S值，计算bi,使之满足：</p><script type="math/tex; mode=display">S = b1 M1 + b2M2 + ... + bnMn</script><p>$bi$值可为0,1。1表示这个物品在背包中，0表示不存在；</p><p>举一个简单的例子：<br>这些物品可能分别重1、5、6、11、14、20，可以用5、6和11组装为一个重为22的背包，而组装一个重为24的背包则是不可能的。<br>一般来说，解决这个问题所需要的的时间似乎是随着物品个数的增加，呈指数增长；</p><p>Merkle-Hellman背包算法的思想是将消息编码为背包问题的解。明文分组长度等于堆中物品的个数，并且明文位与b的值相对应，密文则是计算得到的和值，下图给出了一段用例子中背包问题来加密的明文；<br><img src="https://img-blog.csdnimg.cn/20210512193204589.png" alt="在这里插入图片描述"><br>背包实际上存在两类不同的背包问题：</p><ol><li>线性时间内可解；</li><li>线性时间内不可解；<br>容易解的背包问题可以修改成难解的背包问题。公开秘钥使用难解的背包问题，可以很容易的用来加密明文，但不能用来解密密文，私人秘钥用容易解的背包问题，他给出一个解密的简单方法。不知道私人秘钥的人要破解密文，必须解一个难得背包问题。</li></ol><h3><span id="2超递增背包">2.超递增背包</span></h3><p>对于易解的背包问题，可以选择<strong>超递增序列</strong>，那么相应的背包问题容易求解。<br>超递增序列：<strong>它的每一项都大于它之前所有项之和</strong>，例如{1，3,6，13，27，52}是一个超递增序列，而{1，3，4，9，15，25}则不是。</p><p>超递增背包问题的解很容易找到，计算其总量并与序列中最大的数比较，如果总重量小于这个数，则它不在背包中，如果总重量大于这个数，则它在背包中，背包重量减去这个数，进而考察序列中下一个最大的数，重复直到结束。如果总重量减为0，那么只有一个解，否则，无解。</p><p>例如，总重量为70的一个背包，超递增序列为{2，3，6，13，27，52}；最大重量为52，小于70，所以52在背包中，70-52 = 18，下一个重量27 &gt;18，因此，27不在背包中，在下一个13&lt;18，13在背包中，18-13 = 5，以此类推，再下一个，3与2均在背包中，总重量减为0，表明已求出一个解，如果这个一个M-H背包加密分组，那么对应的密文70的解为110101.</p><p><strong>非超递增序列的背包是困难的问题，它们没有快速算法</strong>。要决定哪一项在背包中的唯一方法，是依次测试所有解，直到你得到正确的解为止。最快的算法仍随背包中物品超递增问题困难，对于后者，当你加入一项到序列中，求解只需要再进行一次运算。</p><p>Merkle-Hellman背包算法就是利用这个性质。私人秘钥是一个超递增背包问题的重量序列。公开秘钥是有相同解的普通背包问题的序列，Merkle和Hellman设计了一种方法可将超递增背包问题转化为普通的背包问题，它们用模运算来完成此变化。</p><h3><span id="3私人秘钥产生公开秘钥">3.私人秘钥产生公开秘钥</span></h3><p>下面说明如何由背包算法由私人秘钥产生公开秘钥：<br>取一个递增序列，如 =={2，3，6，13，27，52}==，用n去乘所有的项，再用m做模数进行模运算，这个模数应比序列中所有的数的和还要大，如105。乘数应与序列中的任何一个数没有公因子，比如31。因此，一般的背包序列为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">2*31 mod105  &#x3D; 623*31 mod105  &#x3D; 936*31 mod105  &#x3D; 8113*31 mod105  &#x3D; 8827*31 mod105  &#x3D; 10252*31 mod105  &#x3D; 37<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，得到的背包为{62,93,81,88,102,37}。<br>超递增背包序列就是私人秘钥，而得到的背包序列就是公开秘钥。</p><h3><span id="4加密过程">4.加密过程</span></h3><p>要加密一个二进制的消息，首先将它分成长度等于背包序列中详述的许多分组。然后，用1表示该项存在，用0表示该项不存在，计算背包的总重量。对所有分组都重复这个运算。<br>例如，如果消息是二进制数011000110101101110，采用上面的背包算法的加密过程如下：</p><p><strong>消息 = 011000   110101  101110<br>011000对应 93 + 81 = 174<br>110101对应 62 + 93 + 88 + 37 = 280<br>101110对应 62 + 81 + 88 + 102 = 333</strong></p><p>因此，密文为 174， 280， 333</p><h3><span id="5解密过程">5.解密过程</span></h3><p>接收者直到私人秘钥：原始的超递增背包、用于把它转换成一般背包的n和m的值，为解密消息，接收者必须首先计算出$n^{-1}$以满足$n*n^{-1} == 1 mod m$。用$n^{-1}$模m乘密文值得每项，然后用私人背包对它进行划分就可获得明文。</p><p>在本例中，超递增背包:<br>=={2，3，6，13，27，52}==<br>m = 105, n = 31，密文消息为174,280，333。$n^{-1} = 61$，所以密文值必须用61模105乘。<br>174 <em> 61 mod 105 = 9 = 3 + 6  对应0111000；<br>280 </em> 61 mod 105 = 70 = 2 + 3 + 13 + 52  对应110101；<br>333 * 61 mod 105 = 48 = 2 + 6 + 13 + 27  对应0111000；<br>因此，恢复出的明文为011000   110101  101110</p><h3><span id="6实际的实现方案">6.实际的实现方案</span></h3><p>要解决仅有6项背包序列的问题不是很难，甚至对非超增序列也是一样。实际使用的背包算法至少应该包含250项。在超递增背包中，每项值一般为200~400位。模数一般为100 ~ 200位。该算法在实际使用中，用随机序列发生器来产生这些值。</p><p>对这样的背包，试图用穷举攻击来破译是无用的。即使一台计算机每秒能计算100万次，试完所有可能的背包值，也需要 $10^{46}$ 年。</p><h3><span id="7背包的安全性">7.背包的安全性</span></h3><p>既然上面说了即使使用穷举攻击无法破译，那么为什么该算法被证明还是可以破解？<br>Shamir支出某些情况下，背包算法能被破译，具体可以查阅相关文献。</p>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cryptography Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学-基础知识概述</title>
      <link href="/posts/9178982e.html"/>
      <url>/posts/9178982e.html</url>
      
        <content type="html"><![CDATA[<h4><span id="1-概述">1、概述</span></h4><p>密码只是信息安全的一部分，它的目的很明确就是为了解决信息安全问题。不同的密码技术算法解决不同的信息安全问题，但没有一种技术能解决所有信息安全问题。</p><p>信息安全有四类特性：</p><ul><li>机密性：为了防止信息被窃听，对应的密码技术有对称密码和非对称密码。</li><li>完整性：为了防止信息被篡改，对应的密码技术有单向散列函数、消息认证码、数字签名。<ul><li>认证：为了防止攻击者伪装成真正的发送者，对应的密码技术有消息认证码和数字签名。</li><li>不可否认性：为了防止发送者事后否认自己没有做过，对应的密码技术为数字签名。</li></ul></li></ul><p>为了尽可能的解决不同的信息安全特性，我们可能需要组合使用多种密码技术。信息安全面临的威胁点和所对应的密码技术之间的关系可用下图来表示：<br><img src="https://img-blog.csdnimg.cn/20210506160358663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt><br>以上主要从类别分类包括6种密码技术：</p><ol><li>对称密码</li><li>非对称密码</li><li>单向散列函数 </li><li>消息认证码 </li><li>数字签名</li><li>伪随机数生成器</li></ol><p>如果看具体的算法，那就包括 <strong>AES、RSA、MD5、SHA1、SHA256、HMAC</strong> 等。有些人还将 BASE64 也理解为一种加解密的密码技术，但BASE64 只是一种编码方式，和 ASCII 和 UTF-8 编码的本质上一样，主要用途就是将不可打印的二进制数据编码为可打印的字符串，因为它不解决信息安全四个特性中的任何一种。大家都知道高性能和高安全是很难兼顾，鱼和熊掌不可兼得，我们能做的是尽力根据自己的业务找到平衡点。下面分别介绍一下这些技术和他们对应的具体算法。</p><h3><span id="2-对称加密">2、对称加密</span></h3><p>对称加密也称为共享密钥密码、私钥密码，是指用相同的密钥加密和解密时的方式。对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。缺点是，交易双方都使用同样钥匙，密钥的分发和管理比较困难，安全性得不到保证。</p><p>常用的对称加密算法有：<strong>DES、3DES、AES、Blowfish、RC5、IDEA</strong> 等，其中DES已经可以现实中被暴力破解，现在的使用最广泛的对称加密算法是 AES。密码算法可以分为分组密码和流密码两种。其中AES和DES都是属于分组密码。分组密码是将明文消息分成一定长度的N个分组，然后对每个分组进行加密。AES的分组长度是128比特，分组密码有很多模式，如果模式选择不恰当，就无法充分保证机密性。</p><p> AES 是一种分组密码，即将明文消息拆分为一定长度的N个分组，然后对每个分组进行加密。AES 的分组长度固定为 128 比特，而密钥可以是 128/192/256比特。既然是固定长度的分组，那我们要加密任意长度的明文，就涉及到如何将多个分组进行迭代加密的问题，因此，就有了分组模式。常用的分组模式有：<strong>ECB、CBC、CFB、OFB、CTR 等</strong>。最常用的是ECB 和 CBC模式，因此，需要了解下这两种模式的用法和区别。</p><p>ECB 全称为 Electronic CodeBook，电子密码本模式，是最简单的一种模式，它直接将明文分割成多个分组并逐个加密，如下图：<br><img src="https://img-blog.csdnimg.cn/20210506160557357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt><br> 这种模式的优点就是简单、快速，加密和解密都支持并行计算。而缺点也比较明显，因为每个明文分组都各自独立地进行加密和解密，如果明文中存在多个相同的明文分组，则这些分组最终会被转换为相同的密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码。另外，攻击者可以通过改变密文分组的顺序，或删除密文分组，或替换掉密文分组，就可以达到对明文操纵的目的，而无需破译密码。在实际应用中，很少需要进行并行计算的加解密场景，因此，一般情况下不会采用这种分组模式，而更推荐采用 CBC 模式。</p><p>CBC 全称为 Cipher Block Chaining，密文分组链接模式，是将前一个密文分组与当前明文分组的内容混合起来进行加密的，如下图：<br><img src="https://img-blog.csdnimg.cn/20210506160630995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt><br>在 CBC 模式中，首先将明文分组与前一个密文分组进行 XOR 运算，然后再进行加密。加密第一个明文分组时，由于不存在“前一个密文分组”，因此需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组”，这个比特序列称为初始化向量(initialization vector)，通常缩写为 IV。CBC 模式避免了 ECB 模式的弱点，明文的重复排列不会反映在密文中。不过，相比 ECB 模式，CBC 模式多了一个初始化向量IV。</p><p>另外，当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行填充，填充方式也有很多种，常用的有两种：PKCS#5 和 PKCS#7。需要注意的就是，不同编程语言使用的填充方式可能会不同。比如，Java 是使用 PKCS#5，而 iOS 的 Objective-C 和 Swift 则采用 PKCS#7。不过，对于 AES 来说，两种填充方式是一样的。</p><p>下图给出了AES加解密的流程示意图<br><img src="https://img-blog.csdnimg.cn/20210506161630288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt></p><p>　　在实际应用中，我们一般都是在前端对密码或其他敏感数据进行加密，然后在后端进行解密。因为前后端涉及到不同语言的实现，为了保证前后端经过加解密后的结果一致，有几个参数是需要保持一致的：</p><ul><li><p>(1) <strong>密钥</strong>：密钥都要使用同一个，这点基本没有疑问，但需要注意的就是，密钥长度需要统一为 128/192/256 比特，即 16/24/32 字节。</p></li><li><p>(2) <strong>分组模式</strong>：分组模式推荐统一为 CBC 模式，且要显式声明，因为不同语言的默认分组模式可能会不同。</p></li><li><p>(3) <strong>初始化向量</strong>：加密和解密时的初始化向量 IV 也是要一致的，同样也不要使用默认设置，而要显式定义。</p></li><li><p>(4) <strong>填充方式</strong>：Java 采用 PKCS5Padding，iOS 和 JavaScript 采用 PKCS7，对于 AES 来说，两者是一样的。</p></li></ul><p>　　还有一点也需要注意，AES 算法本身操作的都是 byte 字节数组，因此，加密后一般会使用 BASE64 编码将 byte 数组转为字符串，而解密之前则先用 BASE64 解码将字符串转回 byte 数组。</p><p>　　使用对称加密最关键的就是要保证密钥的安全，一般不建议直接在网络上传输密钥，另外，在客户端也要做好密钥的安全存储。　　</p><h3><span id="3-非对称加密">3、非对称加密</span></h3><p>　　非对称加密也称公钥加密，使用了一对密钥，用公钥进行加密，再用配对的私钥进行解密。公钥是公开的，而私钥是保密的。相比对称加密安全性提高了，但牺牲了性能，加解密的速度慢了几个数量级，消息越长，加密和解密的速度越慢。</p><p>　　使用最广泛的非对称加密算法就是 RSA，其原理是利用了大整数质因数分解问题的困难度，加密和解密其实就是非常简单的两条公式：</p><p>　　<strong>加密：密文 ＝ 明文^E mod N<br>解密：明文 ＝ 密文^D mod N</strong></p><p>　　即是说，加密就是对明文的 E 次方后除以 N 求余数的过程，其中 E 和 N 的组合就是公钥，即公钥 = (E, N)。而解密过程就是对密文进行 D 次方后除以 N 得到余数，即是明文，D 和 N 的组合就是私钥，即私钥 = (D, N)。公钥和私钥共有的 N 称为 module，即模数，E 和 D 则分别是公钥指数和私钥指数。因为 RSA 是基于以上数学问题的，所以其明文、密钥和密文都是数字，我们平时看到的字符串其实都是二进制表示的数字经过 BASE64 编码的。</p><p>　　密钥长度越长越安全，推荐使用 1024 比特或更大的值，这里说的 1024 密钥长度其实是指模数的长度。还有，不同于对称密码可以加密任意长度的明文，RSA 明文长度是不能超过密钥长度的。Java 默认的 RSA 加密实现明文长度最长为密钥长度减去 11 字节，假如密钥长度设为 1024 比特，即 128 字节，那明文长度则不能超过 128 - 11 = 117 字节，如果超过该长度则会抛异常。如果想要加密的明文比较长，那就生成更长的密钥，如 2048 比特，那明文可以长达 245 字节，足够了。太长的明文也不推荐使用 RSA 进行加密，性能太低了。 </p><p>　　另外，为了提高安全性，RSA 加密时都会填充一些随机数。RSA 加密填充方式主要有三种：NoPadding、PKCS1Padding、OAEPPadding。其中，最常用的就是 PKCS1Padding，它会在明文前面填充 11 字节的随机数，因此，对同一明文每次加密产生的密文都会不一样。如果想让每次加密产生的密文都一样，那填充方式就采用 NoPadding，即不填充，但这样无疑减低了安全性，所以一般不建议采用 NoPadding。</p><p>　　实际应用中，我们不会直接对长消息进行非对称加密，而只会对一些安全性要求非常高的短消息进行加密，比如用户的密码、对称加密的密钥。SSL/TLS 的加密方案就是用对称加密对请求消息进行加密，用公钥加密对对称加密的密钥进行加密。</p><p>想要破解就得通过n算出p和q，但是b比较大，大数的质因分解困难，但是量子计算机很有可能破解。</p><h3><span id="4-单向散列函数">4、单向散列函数</span></h3><p>　　对称加密和非对称加密主要是用来解决消息的机密性问题的，即可以防止消息被窃听导致秘密泄露，但却无法校验消息是否被篡改。要校验消息是否被篡改，就要对消息进行完整性校验，有多种校验方案，最简单高效的就是单向散列函数。</p><p>　　单向散列函数也称哈希函数、杂凑函数、消息摘要算法等，是能把任意长的输入消息串转变成固定长的输出串的一种函数，输出值称为“散列值”或“消息摘要”，也称为消息的“指纹”。使用单向散列函数，同一消息会生成同样的散列值，而只要改了消息，哪怕只改了 1 个字节，最终的散列值变化也很大，因此，很适合用这个散列值校验消息的完整性。</p><p>　　最常用的单向散列函数就是 <strong>MD5</strong> 和 <strong>SHA</strong>，SHA 其实包括了 SHA-1、SHA-224、SHA-256、SHA-384 和 SHA-512，后四种并称为 SHA-2。有时候，我们去下载一些软件的安装文件时，官方一般都会提供对应该文件的 MD5 和 SHA-1 的散列值，以便我们可以对下载后的文件自己生成散列值，再和官方提供的散列值进行比对，就知道这个文件有没有被修改过。</p><p>　　在我们平时的实际应用中，倒是很少会单独使用单向散列函数，一般都会结合其他技术一起使用。毕竟，单独使用的安全性不高。就举用户密码的安全来说吧，很多应用会将用户密码直接 MD5 之后传输给服务端。这种方案主要存在两个安全隐患，一是对于一些不够复杂的密码难以防范彩虹表，二是不同用户如果设置了相同密码那散列值无疑会一样。</p><p>　　先说第一点，首先，先了解下什么是彩虹表。彩虹表是一个用于单向散列函数逆运算的预先计算好的表，为了破解密码的散列值而准备。我们可以简单理解为彩虹表就是在明文和密文之间建立起对应关系的字典表，可以通过已知的密文反查出明文，虽然实际上其原理远比想象中复杂得多。比如说，密码“123456”的 MD5 结果是“E10ADC3949BA59ABBE56E057F20F883E”，那我监听到用户登录的请求，拿到“E10ADC3949BA59ABBE56E057F20F883E”这个密码串时，从准备好的彩虹表中就可以反查出原密码是“123456”。</p><p>再说第二点，设置了相同密码的不同用户，由于他们 MD5 后的散列值全都一样，那么只要破解了其中一个密码，就等于破解了多个用户的密码。</p><p>　　为了应对以上两个问题，比较好的方案就是 MD5 + salt，也称 MD5 加盐，即将原密码拼上一串盐值 salt 之后再进行 MD5。盐值 salt 是一个随机字符串，每个用户的 salt 值一般都是不同的，这样就可以保证不同用户最终 MD5 出来的散列值不一样，而且因为有一串随机字符串，彩虹表也很难发挥作用了。</p><h3><span id="5-消息认证码">5、消息认证码</span></h3><p>　　消息认证码是一种确认完整性并进行认证的技术，英文名称为message authentication code，简称为MAC。 </p><p>　　虽然单向散列函数可以用来对消息进行完整性校验，但无法校验消息是否来自合法的发送者，即无法解决认证问题。要解决发送者的认证问题，最常用的有两种方案，一是采用消息认证码，二是使用数字签名。这一小节我们先来了解下消息认证码。 </p><p>　　消息认证码的输入包括任意长度的消息和一个发送者与接收者之间共享的密钥，它可以输出固定长度的数据，这个数据称为 MAC 值。 </p><p>　　消息认证码的实现方式有很多种，最常用的实现方式就是 HMAC，再具体点，根据使用哪种单向散列函数可分为：HMAC-MD5、HMAC-SHA1、HMAC-SHA256 等等。HMAC 简单理解就是带有密钥的散列函数，因为有了密钥，就可以对发送者进行认证；也因为使用了散列函数，也具有完整性校验的性质。 </p><p>认证的基本流程就是：</p><ul><li>发送者使用共享密钥对消息计算 MAC 值；</li><li>发送者将消息和 MAC 值一起发送给接收者；</li><li>接收者收到消息和 MAC 值后，使用同一个共享密钥对消息计算 MAC 值；</li><li>对比计算出来的 MAC 值和接收到的 MAC 值是否一致，一致则认证成功。</li></ul><p>　　现在，很多接口所添加的 URL 签名机制，其实就是对请求做 MAC 认证，具体的设计细节后面的文章再详细说明。不过，因为使用了共享密钥，因此也存在和对称加密一样的密钥安全问题</p><h3><span id="6-数字签名">6、数字签名</span></h3><p>　　数字签名相当于现实世界中的盖章、签字的功能，使用数字签名可以识别篡改和伪装，还可以防止否认。 </p><p>　　数字签名可以解决发送者的认证问题，而且，数字签名还具有不可抵赖性。数字签名的原理也非常简单，其实就是将非对称加密反过来用。我们知道，非对称加密是用公钥加密，然后用私钥解密。而数字签名则是用私钥加密，生成的密文就是数字签名，再用公钥解密。用私钥进行加密这一行为只能由持有私钥的人完成，正是基于这一事实，才可以将用私钥加密的密文作为签名来对待。而由于公钥是对外公开的，因此任何人都可以用公钥进行解密，即任何人都能够对签名进行验证。</p><p>　　另外，我们也知道，非对称加密本身加密和解密是非常慢的，消息越长，性能越慢，因此，一般不用来加密和解密长消息。同样的，一般也不会直接对长消息签名，通常的做法是对消息的散列值进行签名，因为散列值比较短，所以加密签名相对就会快很多。因此，你会看到数字签名有类似 MD5withRSA、SHA1withRSA 这样的实现。</p><p>　　最后，需要注意一点，像 MD5withRSA 和 SHA1withRSA 这样的数字签名实现可以校验消息完整性、对发送者进行认证、还可防止抵赖，但却不能解决机密性的问题，不要妄想用一种密码技术就能解决所有问题。</p><p>　　不过，数字签名其实不太适合直接用在客户端上。因为客户端要对消息签名，那么客户端就需要保存私钥，那依然有私钥的安全配送和存储问题。数字签名使用最广泛的应该就是用在数字证书上了，这还涉及到 SSL/TLS 和 CA 等，后面的文章再聊这个话题。</p><h3><span id="7-伪随机数生成器">7、伪随机数生成器</span></h3><p>　　伪随机数生成器并不直接解决信息安全问题，但它承担了密钥生成的重要职责。而密钥的重要性就不用多说了。</p><h3><span id="8-总结">8、总结</span></h3><p>密码技术其实非常多，还包括各种单一技术的组合，我们本篇文章所学的只是最基础的一些知识，包括了对称加密、非对称加密、单向散列函数、消息认证码、数字签名这些密码技术的一些必备知识点，只有掌握了这些，才能理解和设计一些安全性更高的应用。 </p><p>　　对称加密和非对称加密用来解决机密性问题，对称加密的速度快，适合用来加密长消息，但密钥在安全配送和客户端的存储是个难点；而非对称加密避免了共享密钥的安全配送和存储问题，但对长消息的加密速度非常慢，只适合用来加密短消息。单向散列函数可以用来对消息进行完整性校验，但很少单独使用。消息认证码简单理解就是带密钥的单向散列函数，既能校验完整性，还能对发送者进行认证，但因为使用了共享密钥，也存在和对称密码一样的共享密钥的安全配送和存储问题。数字签名能解决完整性校验、认证和防止抵赖等问题，最广泛的应用是在数字证书上。</p><p>参考博文：<a href="https://blog.csdn.net/lanxue0803/article/details/80137279">https://blog.csdn.net/lanxue0803/article/details/80137279</a></p>]]></content>
      
      
      <categories>
          
          <category> Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cryptography Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
