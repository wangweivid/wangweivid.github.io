<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/posts/e9912263.html"/>
      <url>/posts/e9912263.html</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/e9912263.htm/cover.jpg" alt></p><p>密码学——公钥密码体系之背包算法1</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学-公钥密码体系之背包算法1</title>
      <link href="/posts/e9912263.html"/>
      <url>/posts/e9912263.html</url>
      
        <content type="html"><![CDATA[<p><img src="./images/cover.jpg" alt></p><p>密码学——公钥密码体系之背包算法1</p><p>众所周知，公钥密码，又称非对称密码，比较常见的是基于以下三种数学难题的公钥密码体制；</p><ol><li>大数因子分解难解性（RSA）</li><li>离散对数难解性（ElGamal）</li><li>椭圆曲线离散对数难解性（ECC）</li></ol><h3 id="1-背包算法"><a href="#1-背包算法" class="headerlink" title="1.背包算法"></a>1.背包算法</h3><p>本次介绍的并不是以上三种类型的公钥密码体制，而是在公钥密码出现之前，就已经存在的公开密码加密算法：背包算法；<br>背包算法是由Merkle和Hellman开发的背包算法。只能用于加密，后来由Shamir将它改进，使之也能用于数字签名；</p><p>背包算法的安全性起源于背包难题，他是一个<strong>NP完全</strong>问题，但后来发现该算法并不安全，但是由于它证明了如何将NP完全问题用于公开秘钥密码学，因此，值得去学习。</p><p>下面介绍一下什么是背包算法：<br>描述：给定一个物品，每个重量不同，能否将这些物品中的几件放入一个背包中，使之等于一个给定的重量？<br>公式化描述：给定一系列值M1,M2，…，Mn，和一个S值，计算bi,使之满足：</p><script type="math/tex; mode=display">S = b1 M1 + b2M2 + ... + bnMn</script><p>$bi$值可为0,1。1表示这个物品在背包中，0表示不存在；</p><p>举一个简单的例子：<br>这些物品可能分别重1、5、6、11、14、20，可以用5、6和11组装为一个重为22的背包，而组装一个重为24的背包则是不可能的。<br>一般来说，解决这个问题所需要的的时间似乎是随着物品个数的增加，呈指数增长；</p><p>Merkle-Hellman背包算法的思想是将消息编码为背包问题的解。明文分组长度等于堆中物品的个数，并且明文位与b的值相对应，密文则是计算得到的和值，下图给出了一段用例子中背包问题来加密的明文；<br><img src="https://img-blog.csdnimg.cn/20210512193204589.png" alt="在这里插入图片描述"><br>背包实际上存在两类不同的背包问题：</p><ol><li>线性时间内可解；</li><li>线性时间内不可解；<br>容易解的背包问题可以修改成难解的背包问题。公开秘钥使用难解的背包问题，可以很容易的用来加密明文，但不能用来解密密文，私人秘钥用容易解的背包问题，他给出一个解密的简单方法。不知道私人秘钥的人要破解密文，必须解一个难得背包问题。</li></ol><h3 id="2-超递增背包"><a href="#2-超递增背包" class="headerlink" title="2.超递增背包"></a>2.超递增背包</h3><p>对于易解的背包问题，可以选择<strong>超递增序列</strong>，那么相应的背包问题容易求解。<br>超递增序列：<strong>它的每一项都大于它之前所有项之和</strong>，例如{1，3,6，13，27，52}是一个超递增序列，而{1，3，4，9，15，25}则不是。</p><p>超递增背包问题的解很容易找到，计算其总量并与序列中最大的数比较，如果总重量小于这个数，则它不在背包中，如果总重量大于这个数，则它在背包中，背包重量减去这个数，进而考察序列中下一个最大的数，重复直到结束。如果总重量减为0，那么只有一个解，否则，无解。</p><p>例如，总重量为70的一个背包，超递增序列为{2，3，6，13，27，52}；最大重量为52，小于70，所以52在背包中，70-52 = 18，下一个重量27 &gt;18，因此，27不在背包中，在下一个13&lt;18，13在背包中，18-13 = 5，以此类推，再下一个，3与2均在背包中，总重量减为0，表明已求出一个解，如果这个一个M-H背包加密分组，那么对应的密文70的解为110101.</p><p><strong>非超递增序列的背包是困难的问题，它们没有快速算法</strong>。要决定哪一项在背包中的唯一方法，是依次测试所有解，直到你得到正确的解为止。最快的算法仍随背包中物品超递增问题困难，对于后者，当你加入一项到序列中，求解只需要再进行一次运算。</p><p>Merkle-Hellman背包算法就是利用这个性质。私人秘钥是一个超递增背包问题的重量序列。公开秘钥是有相同解的普通背包问题的序列，Merkle和Hellman设计了一种方法可将超递增背包问题转化为普通的背包问题，它们用模运算来完成此变化。</p><h3 id="3-私人秘钥产生公开秘钥"><a href="#3-私人秘钥产生公开秘钥" class="headerlink" title="3.私人秘钥产生公开秘钥"></a>3.私人秘钥产生公开秘钥</h3><p>下面说明如何由背包算法由私人秘钥产生公开秘钥：<br>取一个递增序列，如 =={2，3，6，13，27，52}==，用n去乘所有的项，再用m做模数进行模运算，这个模数应比序列中所有的数的和还要大，如105。乘数应与序列中的任何一个数没有公因子，比如31。因此，一般的背包序列为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">2*31 mod105  &#x3D; 623*31 mod105  &#x3D; 936*31 mod105  &#x3D; 8113*31 mod105  &#x3D; 8827*31 mod105  &#x3D; 10252*31 mod105  &#x3D; 37<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，得到的背包为{62,93,81,88,102,37}。<br>超递增背包序列就是私人秘钥，而得到的背包序列就是公开秘钥。</p><h3 id="4-加密过程"><a href="#4-加密过程" class="headerlink" title="4.加密过程"></a>4.加密过程</h3><p>要加密一个二进制的消息，首先将它分成长度等于背包序列中详述的许多分组。然后，用1表示该项存在，用0表示该项不存在，计算背包的总重量。对所有分组都重复这个运算。<br>例如，如果消息是二进制数011000110101101110，采用上面的背包算法的加密过程如下：</p><p><strong>消息 = 011000   110101  101110<br>011000对应 93 + 81 = 174<br>110101对应 62 + 93 + 88 + 37 = 280<br>101110对应 62 + 81 + 88 + 102 = 333</strong></p><p>因此，密文为 174， 280， 333</p><h3 id="5-解密过程"><a href="#5-解密过程" class="headerlink" title="5.解密过程"></a>5.解密过程</h3><p>接收者直到私人秘钥：原始的超递增背包、用于把它转换成一般背包的n和m的值，为解密消息，接收者必须首先计算出$n^{-1}$以满足$n*n^{-1} == 1 mod m$。用$n^{-1}$模m乘密文值得每项，然后用私人背包对它进行划分就可获得明文。</p><p>在本例中，超递增背包:<br>=={2，3，6，13，27，52}==<br>m = 105, n = 31，密文消息为174,280，333。$n^{-1} = 61$，所以密文值必须用61模105乘。<br>174 <em> 61 mod 105 = 9 = 3 + 6  对应0111000；<br>280 </em> 61 mod 105 = 70 = 2 + 3 + 13 + 52  对应110101；<br>333 * 61 mod 105 = 48 = 2 + 6 + 13 + 27  对应0111000；<br>因此，恢复出的明文为011000   110101  101110</p><h3 id="6-实际的实现方案"><a href="#6-实际的实现方案" class="headerlink" title="6.实际的实现方案"></a>6.实际的实现方案</h3><p>要解决仅有6项背包序列的问题不是很难，甚至对非超增序列也是一样。实际使用的背包算法至少应该包含250项。在超递增背包中，每项值一般为200~400位。模数一般为100 ~ 200位。该算法在实际使用中，用随机序列发生器来产生这些值。</p><p>对这样的背包，试图用穷举攻击来破译是无用的。即使一台计算机每秒能计算100万次，试完所有可能的背包值，也需要 $10^{46}$ 年。</p><h3 id="7-背包的安全性"><a href="#7-背包的安全性" class="headerlink" title="7.背包的安全性"></a>7.背包的安全性</h3><p>既然上面说了即使使用穷举攻击无法破译，那么为什么该算法被证明还是可以破解？<br>Shamir支出某些情况下，背包算法能被破译，具体可以查阅相关文献。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学-基础知识概述</title>
      <link href="/posts/9178982e.html"/>
      <url>/posts/9178982e.html</url>
      
        <content type="html"><![CDATA[<h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><p>密码只是信息安全的一部分，它的目的很明确就是为了解决信息安全问题。不同的密码技术算法解决不同的信息安全问题，但没有一种技术能解决所有信息安全问题。</p><p>信息安全有四类特性：</p><ul><li>机密性：为了防止信息被窃听，对应的密码技术有对称密码和非对称密码。</li><li>完整性：为了防止信息被篡改，对应的密码技术有单向散列函数、消息认证码、数字签名。<ul><li>认证：为了防止攻击者伪装成真正的发送者，对应的密码技术有消息认证码和数字签名。</li><li>不可否认性：为了防止发送者事后否认自己没有做过，对应的密码技术为数字签名。</li></ul></li></ul><p>为了尽可能的解决不同的信息安全特性，我们可能需要组合使用多种密码技术。信息安全面临的威胁点和所对应的密码技术之间的关系可用下图来表示：<br><img src="https://img-blog.csdnimg.cn/20210506160358663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt><br>以上主要从类别分类包括6种密码技术：</p><ol><li>对称密码</li><li>非对称密码</li><li>单向散列函数 </li><li>消息认证码 </li><li>数字签名</li><li>伪随机数生成器</li></ol><p>如果看具体的算法，那就包括 <strong>AES、RSA、MD5、SHA1、SHA256、HMAC</strong> 等。有些人还将 BASE64 也理解为一种加解密的密码技术，但BASE64 只是一种编码方式，和 ASCII 和 UTF-8 编码的本质上一样，主要用途就是将不可打印的二进制数据编码为可打印的字符串，因为它不解决信息安全四个特性中的任何一种。大家都知道高性能和高安全是很难兼顾，鱼和熊掌不可兼得，我们能做的是尽力根据自己的业务找到平衡点。下面分别介绍一下这些技术和他们对应的具体算法。</p><h3 id="2、对称加密"><a href="#2、对称加密" class="headerlink" title="2、对称加密"></a>2、对称加密</h3><p>对称加密也称为共享密钥密码、私钥密码，是指用相同的密钥加密和解密时的方式。对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。缺点是，交易双方都使用同样钥匙，密钥的分发和管理比较困难，安全性得不到保证。</p><p>常用的对称加密算法有：<strong>DES、3DES、AES、Blowfish、RC5、IDEA</strong> 等，其中DES已经可以现实中被暴力破解，现在的使用最广泛的对称加密算法是 AES。密码算法可以分为分组密码和流密码两种。其中AES和DES都是属于分组密码。分组密码是将明文消息分成一定长度的N个分组，然后对每个分组进行加密。AES的分组长度是128比特，分组密码有很多模式，如果模式选择不恰当，就无法充分保证机密性。</p><p> AES 是一种分组密码，即将明文消息拆分为一定长度的N个分组，然后对每个分组进行加密。AES 的分组长度固定为 128 比特，而密钥可以是 128/192/256比特。既然是固定长度的分组，那我们要加密任意长度的明文，就涉及到如何将多个分组进行迭代加密的问题，因此，就有了分组模式。常用的分组模式有：<strong>ECB、CBC、CFB、OFB、CTR 等</strong>。最常用的是ECB 和 CBC模式，因此，需要了解下这两种模式的用法和区别。</p><p>ECB 全称为 Electronic CodeBook，电子密码本模式，是最简单的一种模式，它直接将明文分割成多个分组并逐个加密，如下图：<br><img src="https://img-blog.csdnimg.cn/20210506160557357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt><br> 这种模式的优点就是简单、快速，加密和解密都支持并行计算。而缺点也比较明显，因为每个明文分组都各自独立地进行加密和解密，如果明文中存在多个相同的明文分组，则这些分组最终会被转换为相同的密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码。另外，攻击者可以通过改变密文分组的顺序，或删除密文分组，或替换掉密文分组，就可以达到对明文操纵的目的，而无需破译密码。在实际应用中，很少需要进行并行计算的加解密场景，因此，一般情况下不会采用这种分组模式，而更推荐采用 CBC 模式。</p><p>CBC 全称为 Cipher Block Chaining，密文分组链接模式，是将前一个密文分组与当前明文分组的内容混合起来进行加密的，如下图：<br><img src="https://img-blog.csdnimg.cn/20210506160630995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt><br>在 CBC 模式中，首先将明文分组与前一个密文分组进行 XOR 运算，然后再进行加密。加密第一个明文分组时，由于不存在“前一个密文分组”，因此需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组”，这个比特序列称为初始化向量(initialization vector)，通常缩写为 IV。CBC 模式避免了 ECB 模式的弱点，明文的重复排列不会反映在密文中。不过，相比 ECB 模式，CBC 模式多了一个初始化向量IV。</p><p>另外，当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行填充，填充方式也有很多种，常用的有两种：PKCS#5 和 PKCS#7。需要注意的就是，不同编程语言使用的填充方式可能会不同。比如，Java 是使用 PKCS#5，而 iOS 的 Objective-C 和 Swift 则采用 PKCS#7。不过，对于 AES 来说，两种填充方式是一样的。</p><p>下图给出了AES加解密的流程示意图<br><img src="https://img-blog.csdnimg.cn/20210506161630288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpdmlkMTE3,size_16,color_FFFFFF,t_70" alt></p><p>　　在实际应用中，我们一般都是在前端对密码或其他敏感数据进行加密，然后在后端进行解密。因为前后端涉及到不同语言的实现，为了保证前后端经过加解密后的结果一致，有几个参数是需要保持一致的：</p><ul><li><p>(1) <strong>密钥</strong>：密钥都要使用同一个，这点基本没有疑问，但需要注意的就是，密钥长度需要统一为 128/192/256 比特，即 16/24/32 字节。</p></li><li><p>(2) <strong>分组模式</strong>：分组模式推荐统一为 CBC 模式，且要显式声明，因为不同语言的默认分组模式可能会不同。</p></li><li><p>(3) <strong>初始化向量</strong>：加密和解密时的初始化向量 IV 也是要一致的，同样也不要使用默认设置，而要显式定义。</p></li><li><p>(4) <strong>填充方式</strong>：Java 采用 PKCS5Padding，iOS 和 JavaScript 采用 PKCS7，对于 AES 来说，两者是一样的。</p></li></ul><p>　　还有一点也需要注意，AES 算法本身操作的都是 byte 字节数组，因此，加密后一般会使用 BASE64 编码将 byte 数组转为字符串，而解密之前则先用 BASE64 解码将字符串转回 byte 数组。</p><p>　　使用对称加密最关键的就是要保证密钥的安全，一般不建议直接在网络上传输密钥，另外，在客户端也要做好密钥的安全存储。　　</p><h3 id="3、非对称加密"><a href="#3、非对称加密" class="headerlink" title="3、非对称加密"></a>3、非对称加密</h3><p>　　非对称加密也称公钥加密，使用了一对密钥，用公钥进行加密，再用配对的私钥进行解密。公钥是公开的，而私钥是保密的。相比对称加密安全性提高了，但牺牲了性能，加解密的速度慢了几个数量级，消息越长，加密和解密的速度越慢。</p><p>　　使用最广泛的非对称加密算法就是 RSA，其原理是利用了大整数质因数分解问题的困难度，加密和解密其实就是非常简单的两条公式：</p><p>　　<strong>加密：密文 ＝ 明文^E mod N<br>解密：明文 ＝ 密文^D mod N</strong></p><p>　　即是说，加密就是对明文的 E 次方后除以 N 求余数的过程，其中 E 和 N 的组合就是公钥，即公钥 = (E, N)。而解密过程就是对密文进行 D 次方后除以 N 得到余数，即是明文，D 和 N 的组合就是私钥，即私钥 = (D, N)。公钥和私钥共有的 N 称为 module，即模数，E 和 D 则分别是公钥指数和私钥指数。因为 RSA 是基于以上数学问题的，所以其明文、密钥和密文都是数字，我们平时看到的字符串其实都是二进制表示的数字经过 BASE64 编码的。</p><p>　　密钥长度越长越安全，推荐使用 1024 比特或更大的值，这里说的 1024 密钥长度其实是指模数的长度。还有，不同于对称密码可以加密任意长度的明文，RSA 明文长度是不能超过密钥长度的。Java 默认的 RSA 加密实现明文长度最长为密钥长度减去 11 字节，假如密钥长度设为 1024 比特，即 128 字节，那明文长度则不能超过 128 - 11 = 117 字节，如果超过该长度则会抛异常。如果想要加密的明文比较长，那就生成更长的密钥，如 2048 比特，那明文可以长达 245 字节，足够了。太长的明文也不推荐使用 RSA 进行加密，性能太低了。 </p><p>　　另外，为了提高安全性，RSA 加密时都会填充一些随机数。RSA 加密填充方式主要有三种：NoPadding、PKCS1Padding、OAEPPadding。其中，最常用的就是 PKCS1Padding，它会在明文前面填充 11 字节的随机数，因此，对同一明文每次加密产生的密文都会不一样。如果想让每次加密产生的密文都一样，那填充方式就采用 NoPadding，即不填充，但这样无疑减低了安全性，所以一般不建议采用 NoPadding。</p><p>　　实际应用中，我们不会直接对长消息进行非对称加密，而只会对一些安全性要求非常高的短消息进行加密，比如用户的密码、对称加密的密钥。SSL/TLS 的加密方案就是用对称加密对请求消息进行加密，用公钥加密对对称加密的密钥进行加密。</p><p>想要破解就得通过n算出p和q，但是b比较大，大数的质因分解困难，但是量子计算机很有可能破解。</p><h3 id="4、单向散列函数"><a href="#4、单向散列函数" class="headerlink" title="4、单向散列函数"></a>4、单向散列函数</h3><p>　　对称加密和非对称加密主要是用来解决消息的机密性问题的，即可以防止消息被窃听导致秘密泄露，但却无法校验消息是否被篡改。要校验消息是否被篡改，就要对消息进行完整性校验，有多种校验方案，最简单高效的就是单向散列函数。</p><p>　　单向散列函数也称哈希函数、杂凑函数、消息摘要算法等，是能把任意长的输入消息串转变成固定长的输出串的一种函数，输出值称为“散列值”或“消息摘要”，也称为消息的“指纹”。使用单向散列函数，同一消息会生成同样的散列值，而只要改了消息，哪怕只改了 1 个字节，最终的散列值变化也很大，因此，很适合用这个散列值校验消息的完整性。</p><p>　　最常用的单向散列函数就是 <strong>MD5</strong> 和 <strong>SHA</strong>，SHA 其实包括了 SHA-1、SHA-224、SHA-256、SHA-384 和 SHA-512，后四种并称为 SHA-2。有时候，我们去下载一些软件的安装文件时，官方一般都会提供对应该文件的 MD5 和 SHA-1 的散列值，以便我们可以对下载后的文件自己生成散列值，再和官方提供的散列值进行比对，就知道这个文件有没有被修改过。</p><p>　　在我们平时的实际应用中，倒是很少会单独使用单向散列函数，一般都会结合其他技术一起使用。毕竟，单独使用的安全性不高。就举用户密码的安全来说吧，很多应用会将用户密码直接 MD5 之后传输给服务端。这种方案主要存在两个安全隐患，一是对于一些不够复杂的密码难以防范彩虹表，二是不同用户如果设置了相同密码那散列值无疑会一样。</p><p>　　先说第一点，首先，先了解下什么是彩虹表。彩虹表是一个用于单向散列函数逆运算的预先计算好的表，为了破解密码的散列值而准备。我们可以简单理解为彩虹表就是在明文和密文之间建立起对应关系的字典表，可以通过已知的密文反查出明文，虽然实际上其原理远比想象中复杂得多。比如说，密码“123456”的 MD5 结果是“E10ADC3949BA59ABBE56E057F20F883E”，那我监听到用户登录的请求，拿到“E10ADC3949BA59ABBE56E057F20F883E”这个密码串时，从准备好的彩虹表中就可以反查出原密码是“123456”。</p><p>再说第二点，设置了相同密码的不同用户，由于他们 MD5 后的散列值全都一样，那么只要破解了其中一个密码，就等于破解了多个用户的密码。</p><p>　　为了应对以上两个问题，比较好的方案就是 MD5 + salt，也称 MD5 加盐，即将原密码拼上一串盐值 salt 之后再进行 MD5。盐值 salt 是一个随机字符串，每个用户的 salt 值一般都是不同的，这样就可以保证不同用户最终 MD5 出来的散列值不一样，而且因为有一串随机字符串，彩虹表也很难发挥作用了。</p><h3 id="5、消息认证码"><a href="#5、消息认证码" class="headerlink" title="5、消息认证码"></a>5、消息认证码</h3><p>　　消息认证码是一种确认完整性并进行认证的技术，英文名称为message authentication code，简称为MAC。 </p><p>　　虽然单向散列函数可以用来对消息进行完整性校验，但无法校验消息是否来自合法的发送者，即无法解决认证问题。要解决发送者的认证问题，最常用的有两种方案，一是采用消息认证码，二是使用数字签名。这一小节我们先来了解下消息认证码。 </p><p>　　消息认证码的输入包括任意长度的消息和一个发送者与接收者之间共享的密钥，它可以输出固定长度的数据，这个数据称为 MAC 值。 </p><p>　　消息认证码的实现方式有很多种，最常用的实现方式就是 HMAC，再具体点，根据使用哪种单向散列函数可分为：HMAC-MD5、HMAC-SHA1、HMAC-SHA256 等等。HMAC 简单理解就是带有密钥的散列函数，因为有了密钥，就可以对发送者进行认证；也因为使用了散列函数，也具有完整性校验的性质。 </p><p>认证的基本流程就是：</p><ul><li>发送者使用共享密钥对消息计算 MAC 值；</li><li>发送者将消息和 MAC 值一起发送给接收者；</li><li>接收者收到消息和 MAC 值后，使用同一个共享密钥对消息计算 MAC 值；</li><li>对比计算出来的 MAC 值和接收到的 MAC 值是否一致，一致则认证成功。</li></ul><p>　　现在，很多接口所添加的 URL 签名机制，其实就是对请求做 MAC 认证，具体的设计细节后面的文章再详细说明。不过，因为使用了共享密钥，因此也存在和对称加密一样的密钥安全问题</p><h3 id="6、数字签名"><a href="#6、数字签名" class="headerlink" title="6、数字签名"></a>6、数字签名</h3><p>　　数字签名相当于现实世界中的盖章、签字的功能，使用数字签名可以识别篡改和伪装，还可以防止否认。 </p><p>　　数字签名可以解决发送者的认证问题，而且，数字签名还具有不可抵赖性。数字签名的原理也非常简单，其实就是将非对称加密反过来用。我们知道，非对称加密是用公钥加密，然后用私钥解密。而数字签名则是用私钥加密，生成的密文就是数字签名，再用公钥解密。用私钥进行加密这一行为只能由持有私钥的人完成，正是基于这一事实，才可以将用私钥加密的密文作为签名来对待。而由于公钥是对外公开的，因此任何人都可以用公钥进行解密，即任何人都能够对签名进行验证。</p><p>　　另外，我们也知道，非对称加密本身加密和解密是非常慢的，消息越长，性能越慢，因此，一般不用来加密和解密长消息。同样的，一般也不会直接对长消息签名，通常的做法是对消息的散列值进行签名，因为散列值比较短，所以加密签名相对就会快很多。因此，你会看到数字签名有类似 MD5withRSA、SHA1withRSA 这样的实现。</p><p>　　最后，需要注意一点，像 MD5withRSA 和 SHA1withRSA 这样的数字签名实现可以校验消息完整性、对发送者进行认证、还可防止抵赖，但却不能解决机密性的问题，不要妄想用一种密码技术就能解决所有问题。</p><p>　　不过，数字签名其实不太适合直接用在客户端上。因为客户端要对消息签名，那么客户端就需要保存私钥，那依然有私钥的安全配送和存储问题。数字签名使用最广泛的应该就是用在数字证书上了，这还涉及到 SSL/TLS 和 CA 等，后面的文章再聊这个话题。</p><h3 id="7、伪随机数生成器"><a href="#7、伪随机数生成器" class="headerlink" title="7、伪随机数生成器"></a>7、伪随机数生成器</h3><p>　　伪随机数生成器并不直接解决信息安全问题，但它承担了密钥生成的重要职责。而密钥的重要性就不用多说了。</p><h3 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h3><p>密码技术其实非常多，还包括各种单一技术的组合，我们本篇文章所学的只是最基础的一些知识，包括了对称加密、非对称加密、单向散列函数、消息认证码、数字签名这些密码技术的一些必备知识点，只有掌握了这些，才能理解和设计一些安全性更高的应用。 </p><p>　　对称加密和非对称加密用来解决机密性问题，对称加密的速度快，适合用来加密长消息，但密钥在安全配送和客户端的存储是个难点；而非对称加密避免了共享密钥的安全配送和存储问题，但对长消息的加密速度非常慢，只适合用来加密短消息。单向散列函数可以用来对消息进行完整性校验，但很少单独使用。消息认证码简单理解就是带密钥的单向散列函数，既能校验完整性，还能对发送者进行认证，但因为使用了共享密钥，也存在和对称密码一样的共享密钥的安全配送和存储问题。数字签名能解决完整性校验、认证和防止抵赖等问题，最广泛的应用是在数字证书上。</p><p>参考博文：<a href="https://blog.csdn.net/lanxue0803/article/details/80137279">https://blog.csdn.net/lanxue0803/article/details/80137279</a></p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
